{
  "hash": "5a67a5e5b5681732ecfa6da73689559d",
  "result": {
    "markdown": "---\ntitle: \"typical90-05\"\nauthor: \"Serika Yuzuki\"\ndate: \"2023-10-17\"\ncategories: [AtCoder, Programming]\nimage: \"images/thumbnail.webp\"\n---\n\n## 概要\n\n解き切ってない。問題はアルゴリズムというよりかは、行列などの扱いや変数の大きさなどのようだ。\n\n\n```{css, echo=FALSE}\npre {\n  max-height: 300px;\n  overflow-y: auto;\n}\n\npre[class] {\n  max-height: 100px;\n}\n```\n\n\ntest\n\n```rust\n//いつかリベンジ！！\n\nuse std::env;\nuse nalgebra::DMatrix;\nuse proconio::input;\n\nfn main() {\n    //env::set_var(\"RUST_BACKTRACE\", \"full\");\n    input! {\n        numbers_length: usize,\n        devider: usize,\n        digits: usize,\n        numbers: [usize; digits],\n    }\n\n    // 340282366920938463463374607431768211455\n    // 19318074092350443561\n    // 11710352956716025284\n\n    // for debug18446744073709551615\n\n    // let numbers_length: usize = 111;\n    // let devider : usize = 29;\n    // let digits: usize = 6;\n    // let numbers : Vec<usize>= vec![1,2,3,5,6,7,9];\n\n    let modular : u128 = 1000000007;\n\n    let mut rem_vec : Vec<usize> = vec![1];\n    let mut begin_index : usize = 0;\n    let mut end_index : usize= 0;\n    let mut loop_len : usize = 0;\n\n    for i in 0..devider {\n        let tmp_rem = (rem_vec.last().unwrap() * 10 ) % devider;\n        if rem_vec.binary_search(&tmp_rem).is_ok() {\n            begin_index = rem_vec.binary_search(&tmp_rem).unwrap();\n            end_index = rem_vec.len();\n            loop_len = end_index - begin_index;\n            break;\n        }\n        rem_vec.push( tmp_rem );\n    }\n\n    let (non_looped_side, looped_side) = rem_vec.split_at(begin_index);\n\n    // looped_rem[i][j] i*10^j-th % devider\n    let mut looped_rem : Vec<Vec<usize>> = Vec::new();\n    let mut non_looped_rem : Vec<Vec<usize>> = Vec::new();\n\n    for num in numbers {\n        let mut tmp_looped_rem = vec![];\n        let mut tmp_nonlooped_rem = vec![];\n        for i in looped_side {\n            tmp_looped_rem.push( (i * num) % devider );\n        }\n        looped_rem.push(tmp_looped_rem);\n        for i in non_looped_side {\n            tmp_nonlooped_rem.push( (i * num) % devider );\n        }\n        non_looped_rem.push(tmp_nonlooped_rem);\n    }\n\n    let mut beginning_vec : DMatrix<u128> = DMatrix::from_vec( devider, 1, vec![0; devider]);\n    beginning_vec[(0,0)] = 1;\n\n    // container[i][j] means how many numbers remain i in j-th digit in the loop\n    let mut looped_container : Vec<DMatrix<u128>> = Vec::new();\n\n    for jndex in 0..looped_rem[0].len() {\n        let mut vec_tmp_0 = vec![0 as u128; devider];\n\n        for index in 0..digits {\n            vec_tmp_0[looped_rem[index][jndex]] += 1;\n        }\n\n        looped_container.push(generate_calc_matrix(vec_tmp_0));\n    }\n\n    // container[i][j] means how many numbers remain i in j-th digit in the non-loop\n    let mut non_looped_container : Vec<DMatrix<u128>> = Vec::new();\n\n    if non_looped_rem.len() != 0 {\n        for jndex in 0..non_looped_rem[0].len() {\n            let mut vec_tmp_0 = vec![0 as u128; devider];\n            for index in 0..digits {\n                vec_tmp_0[non_looped_rem[index][jndex]] += 1;\n            }\n\n            non_looped_container.push(generate_calc_matrix(vec_tmp_0));\n        }\n    }\n\n    let ans = calc_mat(non_looped_container.clone(), looped_container.clone(), beginning_vec.clone(), numbers_length, modular);\n\n    println!(\"{}\", ans % modular as u128);\n\n}\n\nfn calc_mat(non_looped_container : Vec<DMatrix<u128>>, looped_container : Vec<DMatrix<u128>>, beginning_vec : DMatrix<u128>, number_length : usize, modular: u128) -> u128 {\n    if non_looped_container.len() != 0 {\n        if non_looped_container.len() >= number_length {\n            let mut tmp_mat = non_looped_container[0].clone();\n            for i in 1..number_length {\n                tmp_mat = &non_looped_container[i] * &tmp_mat;\n                for j in 0..tmp_mat.nrows() {\n                    for k in 0..tmp_mat.ncols() {\n                        tmp_mat[(j,k)] %= modular as u128;\n                    }\n                }\n            }\n            let ans = tmp_mat * beginning_vec;\n            let ans_u = ans[(0,0)];\n            return ans_u;\n        }\n        else {\n            let mut nl_tmp_mat = non_looped_container[0].clone();\n            for i in 1..non_looped_container.len() {\n                nl_tmp_mat = &non_looped_container[i] * &nl_tmp_mat;\n                for j in 0..nl_tmp_mat.nrows() {\n                    for k in 0..nl_tmp_mat.ncols() {\n                        nl_tmp_mat[(j,k)] %= modular;\n                    }\n                }\n            }\n            let mut new_beginning_vec = nl_tmp_mat * beginning_vec;\n\n            let loop_number = number_length - non_looped_container.len();\n\n            let ans = calc_looped(looped_container, new_beginning_vec, loop_number, modular);\n\n            let ans_u = ans[(0,0)];\n\n            return ans_u;\n        }\n    } else {\n        let ans = calc_looped(looped_container, beginning_vec, number_length, modular);\n\n        let ans_u = ans[(0,0)];\n\n        return ans_u;\n    }\n}\n\nfn calc_looped (looped_container : Vec<DMatrix<u128>>, beginning_vec : DMatrix<u128>, number_length : usize, modular : u128) -> DMatrix<u128> {\n    if looped_container.len() >= number_length {\n        let mut tmp_mat = looped_container[1].clone();\n        for i in 2..number_length {\n            tmp_mat = &looped_container[i] * &tmp_mat;\n            for j in 0..tmp_mat.nrows() {\n                for k in 0..tmp_mat.ncols() {\n                    tmp_mat[(j,k)] %= modular;\n                }\n            }\n        }\n        return tmp_mat * beginning_vec;\n    }\n    else {\n        let mut tmp_mat_one_loop = looped_container[0].clone();\n        for i in 1..looped_container.len() {\n            tmp_mat_one_loop = &looped_container[i] * &tmp_mat_one_loop;\n            for j in 0..tmp_mat_one_loop.nrows() {\n                for k in 0..tmp_mat_one_loop.ncols() {\n                    tmp_mat_one_loop[(j,k)] %= modular;\n                }\n            }\n        }\n\n        let loop_number = number_length / looped_container.len();\n\n        // １回のループでできる行列はできたので、あとはloop_number回のループを行う\n        let mut ans = calc_power(tmp_mat_one_loop, loop_number, modular);\n\n        let loop_number_remain = number_length % looped_container.len();\n\n        if loop_number_remain != 0 {\n            let mut tmp_mat = looped_container[0].clone();\n            for i in 1..loop_number_remain {\n                tmp_mat = &looped_container[i] * &tmp_mat;\n                for j in 0..tmp_mat.nrows() {\n                    for k in 0..tmp_mat.ncols() {\n                        tmp_mat[(j,k)] %= modular;\n                    }\n                }\n            }\n            ans = tmp_mat * ans;\n        }\n\n        for j in 0..ans.nrows() {\n            for k in 0..ans.ncols() {\n                ans[(j,k)] %= modular;\n            }\n        }\n\n        return ans * beginning_vec;\n    }\n}\n\nfn calc_power (mat: DMatrix<u128>, power : usize, modular : u128) -> DMatrix<u128> {\n    let mut binary : Vec<usize> = format!(\"{:b}\", power).chars().map(|c| c.to_digit(10).unwrap() as usize).collect();\n\n    binary.reverse();\n\n    let mut ans_mat = DMatrix::from_element(mat.nrows(), mat.ncols(), 0);\n\n    for i in 0..binary.len() {\n        if binary[i] == 0 {\n            continue;\n        } else {\n            if ans_mat == DMatrix::from_element(mat.nrows(), mat.ncols(), 0) {\n                ans_mat = calc_binary_power(mat.clone(), i, modular);\n            }\n            else {\n                ans_mat = ans_mat * calc_binary_power(mat.clone(), i, modular);\n                for j in 0..ans_mat.nrows() {\n                    for k in 0..ans_mat.ncols() {\n                        ans_mat[(j,k)] %= modular;\n                    }\n                }\n            }\n\n        }\n    }\n\n\n\n    ans_mat\n}\n\nfn calc_binary_power (mat: DMatrix<u128>, power_size: usize, modular : u128) -> DMatrix<u128> {\n    let mut ans_mat = DMatrix::from_element(mat.nrows(), mat.ncols(), 0);\n\n    if power_size == 0 {\n        return mat;\n    }\n\n    for i in 1..power_size+1 {\n        if i == 1 {\n            ans_mat = &mat * &mat;\n        } else {\n            ans_mat = &ans_mat * &ans_mat;\n            // alith\n            for j in 0..ans_mat.nrows() {\n                for k in 0..ans_mat.ncols() {\n                    ans_mat[(j,k)] %= modular;\n                }\n            }\n        }\n    }\n\n    ans_mat\n}\n\nfn generate_calc_matrix(rem_vec : Vec<u128>) -> DMatrix<u128> {\n    let mut tmp_bm = vec![];\n\n    let size = rem_vec.len();\n\n    for index in 0..size {\n        let mut tmp_left = rem_vec[0..index+1].to_vec();\n        tmp_left.reverse();\n        let mut tmp_right = rem_vec[index+1..size].to_vec();\n        tmp_right.reverse();\n        let mut tmp_vec = tmp_left;\n        tmp_vec.append(&mut tmp_right);\n\n        tmp_bm.append(&mut tmp_vec);\n    }\n\n    DMatrix::from_vec(size, size, tmp_bm)\n}\n\n```\n\n## 発見\n\n### Vecの中身を探すとき\n\n```rust\nlet vec = vec![1,3,5];\nlet res1 = vec.binary_search(&2).is_ok();\nassert_eq!(res1, false);\nlet res2 = vec.binary_search(&3).is_ok();\nassert_eq!(res2, true);\n```\n\n## 問題点\n\n",
    "supporting": [
      "typical90-05_files"
    ],
    "filters": [],
    "includes": {}
  }
}