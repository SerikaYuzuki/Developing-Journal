[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Serika Yuzuki",
    "section": "",
    "text": "柚木芹香です。よろしくお願いします。"
  },
  {
    "objectID": "about.html#私の取扱説明書",
    "href": "about.html#私の取扱説明書",
    "title": "Serika Yuzuki",
    "section": "私の取扱説明書",
    "text": "私の取扱説明書\n就活の自己PRとかに流用する予定の場所でもあります。\n\n概説\nとりあえずこれを見れば大体わかる気がします。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nENTP\nENTPの人間です。と言っても他人の気分を損なうような議論が好きな人ではないです。\n代わりに、自分の考えを言い切ることが好きです。そのため、自分の考えを言い切ることができる環境を好みます。また、否定されるであろう前提で意見を表明し、その否定される過程で何か見つけられないかと探すことが多いので、私の意見＝私の考えではありません。\n\n\nADHD\n重度のADHDのため、一度の退学を経験しています。正直、ある程度の自由度が与えられている割には、定期的な出席を自発的に達成しないといけないという大学の環境は、自分に合っていないと感じることが多いですが、それでもなんとか頑張っています。\n代わりに、というのかはわかりませんが、短い間での集中力は無かりのものがあり、任意の事柄に対する理解速度は他人と比肩ならないものがあると信じています。おかげで２度の東京大学の合格や、数学オリンピック、物理オリンピックの参加などを経験しています。オリンピックについてはメダル獲得には至りませんでしたが、それなりの点数を取ることはできました。\nまた、広く色々な事柄について興味を持つことにも長けています。事実、軽いweb開発やLaTex、簡単な深層学習など、色々と手を出しています。広く浅い知識を運用することによって、作業中の特定の事項や問題において、突破点となる第３の選択肢を見つけることができると信じています。\n\n\nゲーム関連に進みたい理由\n人生でゲーム開発に関わる作業をしたのは、BF1942という2002年発売のゲームのModを制作したことでした。\n\n\n\n\n\nBF1942のパッケージ\n\n\nゲーム自体の開発ではな買ったのですが、自分が提案した遊び方を友人と共有し、喜んでもらえることが、ゲーム開発業界に関わりたいと思い始めたきっかけでした。とは言っても、iniファイルをちょっと弄って、武器の威力を変えたり、弾薬の数を変えたりするだけのものでしたが、それでも普段とは違う楽しみを見つけて友人と共有できたことは、今でも忘れられません。\n今現在、個人でUE5を勉強していますが、UEの膨大な機能のために自分がどのように勉強を進めるべきかをゆっくり見つけながら進めています。今現在はUdemyでの講座を進めながら、裏でUEのドキュメントを読み進めています。\n:::"
  },
  {
    "objectID": "posts/ue5_project/planning.html",
    "href": "posts/ue5_project/planning.html",
    "title": "Planning",
    "section": "",
    "text": "ポートフォリオ用に作るゲームの計画。"
  },
  {
    "objectID": "posts/ue5_project/planning.html#概要",
    "href": "posts/ue5_project/planning.html#概要",
    "title": "Planning",
    "section": "",
    "text": "ポートフォリオ用に作るゲームの計画。"
  },
  {
    "objectID": "posts/ue5_project/planning.html#計画",
    "href": "posts/ue5_project/planning.html#計画",
    "title": "Planning",
    "section": "計画",
    "text": "計画\n大きく考えているやりたいことについて書いていく。\n\nストーリー分岐があるRPG\n負けイベントを壊せる\nMMDを使いたい\n簡単な人生ゲームのような、友達と気軽に遊べるゲーム\nコミュニケーションツールとしてのゲーム\nRTSゲームを作りたい\nソウルライクなゲームを作りたい\nギャンブルのような中毒性を入れたい"
  },
  {
    "objectID": "posts/ue5_aura_courses/template.html#発見",
    "href": "posts/ue5_aura_courses/template.html#発見",
    "title": "template",
    "section": "発見",
    "text": "発見\n\n問題"
  },
  {
    "objectID": "posts/ue5_aura_courses/template.html#問題点",
    "href": "posts/ue5_aura_courses/template.html#問題点",
    "title": "template",
    "section": "問題点",
    "text": "問題点"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_02.html",
    "href": "posts/ue5_aura_courses/section_02.html",
    "title": "Section 02",
    "section": "",
    "text": "Sec 02 について"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_02.html#流れ",
    "href": "posts/ue5_aura_courses/section_02.html#流れ",
    "title": "Section 02",
    "section": "流れ",
    "text": "流れ\n\nまずRiderで作業するのに集中するために、Auto CompileやLive Codingを消した。\nキャラクターの基本のセットアップ\n\nCreated Character Class\nCreated Weapon object and attached to mesh\nApplied Animation\n\nSetting up player enhanced input\n\nPrivate Dependency Module にEnhanced Inputを入れないといけない\n\nSetup GameModeBase and GameBase\n\nSetup PlayerController\nCasting input to enhanced input\nSetup Move function\n\nhighlight the enemy when mouse over\n\nby creating interface\nHighlighting via post process material\n\nadd post process volume and make it extens infinite\ncustom depth stencil : Enabled with Stencil\nadd PP_highlighing material to post process volume\nchange enemy actor’s custom depth"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_02.html#発見",
    "href": "posts/ue5_aura_courses/section_02.html#発見",
    "title": "Section 02",
    "section": "発見",
    "text": "発見\n\nBindActionの第4引数に渡す関数ポインタの型をドキュメントで知りたい\nvoid AAuraPlayerController::SetupInputComponent()\n{\n    ...\n    EnhancedInputComponent-&gt;BindAction(MoveAction, ETriggerEvent::Triggered, this, &AAuraPlayerController::Move);\n}\n\nvoid AAuraPlayerController::Move(const FInputActionValue& Value) {...}\nBindActionの第4引数には、void (AAuraPlayerController::*)(const FInputActionValue&) という型の関数ポインタを渡す必要がある。これはどこを読めばわかるのか？\nBindActionのドキュメントによれば、上の関数の引数の形は\ntemplate&lt;class UserClass&gt;\nFInputActionBinding & BindAction\n(\n    const FName ActionName,\n    const EInputEvent KeyEvent,\n    UserClass * Object,\n    typename FInputActionHandlerWithKeySignature::TMethodPtr&lt; UserClass &gt; Func\n)\nで、この第四引数であるFEnhancedInputActionHandlerValueSignatureのドキュメントによれば、 typedef TBaseDelegate_OneParam&lt; void, const FInputActionValue & &gt; FEnhancedInputActionHandlerValueSignature\n\n\nRotation MatrixのGetUnitAxisの意味\nconst FVector2D InputAxisVector = Value.Get&lt;FVector2D&gt;();\nconst FRotator Rotation = GetControlRotation();\nconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\nconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\nconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\nif (APawn* ContrlledPawn = GetPawn&lt;APawn&gt;())\n{\n    ContrlledPawn-&gt;AddMovementInput(ForwardDirection, InputAxisVector.Y);\n    ContrlledPawn-&gt;AddMovementInput(RightDirection, InputAxisVector.X);\n}\nFRotationMatrix(YawRotation) は、YawRotationを回転行列に変換している。この回転行列は、YawRotationの回転軸をZ軸にしている。ここまではいいが、行列にする意味は何か？\nGetUnitAxis(EAxis::X) は、回転行列の1列目を取得していることになる。\n\\[\n\\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\longmapsto\n\\begin{pmatrix}\n\\cos\\theta \\\\\n\\sin\\theta \\\\\n0\n\\end{pmatrix}\n,\n\\begin{pmatrix}\n-\\sin\\theta \\\\\n\\cos\\theta \\\\\n0\n\\end{pmatrix}\n,\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n1\n\\end{pmatrix}\n\\]\nこれについて考えれば、1,2,3列目のベクトルとは、回転後のベクトルの、向いている方向、その方向を \\(x'\\) 軸として作り上げる右手系 \\(x', y', z'\\) の基底ベクトルになっていることがわかる。\nGetControlRotation()でControl世界の回転を取得しているので、その世界の \\(x, y\\) 軸への方向に動きを制限して、Inputを適用している。\n\n\n仮想関数周り\nclass Parent{\npublic:\n    virtual void VFunc() { std::cout &lt;&lt; \"Parent\" &lt;&lt; std::endl; }\n    void NVFunc() { std::cout &lt;&lt; \"Parent\" &lt;&lt; std::endl; }\n};\n\nclass Child : public Parent{\npublic:\n    void VFunc() override { std::cout &lt;&lt; \"Child\" &lt;&lt; std::endl; }\n    void NVFunc() { std::cout &lt;&lt; \"Child\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    Parent* p = new Child();\n    // Parentとしてpを定義しているので、virtualじゃない関数はParentのものが呼ばれる\n    p-&gt;VFunc(); // Child\n    // virtualな関数はChildのものが呼ばれる\n    p-&gt;NVFunc(); // Parent\n}\n以上がvirtualについての話で、sub classで書き換えられる前提の関数は次のように書く。\nclass Parent{\npublic:\n    virtual void VFunc() = 0;\n};\n\n\nTick関連の話\nPrimaryActorTick.bCanEverTick = true;\nこれをContructorで設定しないとTickしない。ただし、PlayerControllerはデフォルトでPlayerTickするようになっている。\n\n\nCollision Channelの話\nCharacter Collision PresetではECC_VisibilityがOffになってるんで気をつけて。"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_04.html",
    "href": "posts/ue5_aura_courses/section_04.html",
    "title": "section_04",
    "section": "",
    "text": "Sec 04 について"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_04.html#概要",
    "href": "posts/ue5_aura_courses/section_04.html#概要",
    "title": "section_04",
    "section": "概要",
    "text": "概要\n\nSetup Attributes\n\nDo NOT let one ability system component have multiple SAME Attributes. This may lead to ambiguity. Having multiple SEPARATE Attributes is allowed.\nCreate a FGameplayAttributeData Health, MaxHealth, Mana, MaxMana;\nIn uproperty refer ReplicatedUsing = Function: OnRep_BluBlu\noverride GetLifetimeReplicatedProps and use DOREPLIFETIME_CONDITION_NOTIFY macro\n\nAbout GetLifetimeReplicatedProps: Returns the properties used for network replication, this needs to be overridden by all actor classes with native replicated properties\n\nSetup variables accessable by macro\n\nDetail about ATTRIBUTE_ACCESSORS is at bottom.\nOnce you setup ATT… then you can easily use functions like InitHealth(100.f).\n\nFor learning purpose, create a actor to change Attributes instead of Gameplay Effect.\n\nCreating mesh and sphere component.\nSetting up OnOverlap, EndOverlap event functions and delecates.\nIn OnOverlap, we can search Actor who is IAbilitySystemInterface and GetAbilitySystemComponent\n\nNote that GetAttributeSet need Parameter of The type of attribute set to look for\n\nconst_cast is used for modify AttributeSet, but this is not recommended. It will be fixed in the future."
  },
  {
    "objectID": "posts/ue5_aura_courses/section_04.html#発見",
    "href": "posts/ue5_aura_courses/section_04.html#発見",
    "title": "section_04",
    "section": "発見",
    "text": "発見\n\nATTRIBUTE_ACCESSORSのマクロについて。\n/**\n * This defines a set of helper functions for accessing and initializing attributes, to avoid having to manually write these functions.\n * It would creates the following functions, for attribute Health\n *\n *  static FGameplayAttribute UMyHealthSet::GetHealthAttribute();\n *  FORCEINLINE float UMyHealthSet::GetHealth() const;\n *  FORCEINLINE void UMyHealthSet::SetHealth(float NewVal);\n *  FORCEINLINE void UMyHealthSet::InitHealth(float NewVal);\n *\n * To use this in your game you can define something like this, and then add game-specific functions as necessary:\n * \n *  #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \\\n *  GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \\\n *  GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \\\n *  GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \\\n *  GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)\n * \n *  ATTRIBUTE_ACCESSORS(UMyHealthSet, Health)\n */\n\n\nDelecate について。\nこれは要するに、関数のアドレスを渡して実行させていると考えて良さそうだ。\nSphere-&gt;OnComponentBeginOverlap.AddDynamic(this, &AAuraEffectActor::OnOverlap);\nこのコードがあるが、大元のEffectActorがTickしてないが、SphereはTickしている。EAがTickする必要はないが、TickしているSphereがEAを知らずにEAの関数を実行することができる。\nif (Sphere-&gt;IsOverlap)\n{\n    OnOverlap();\n}\nにしない理由はEAがTickしないから。\n以上が適当に考えた理由。もっと詳しくはもう少し調べていかなければならない。わかりやすかったリンクが これ\n次に、Delegateの関数の引数の種類については、OnComponentBeginOverlapのDefに書いてある。\nDECLARE_DYNAMIC_MULTICAST_SPARSE_DELEGATE_SixParams( FComponentBeginOverlapSignature, UPrimitiveComponent, OnComponentBeginOverlap, UPrimitiveComponent*, OverlappedComponent, AActor*, OtherActor, UPrimitiveComponent*, OtherComp, int32, OtherBodyIndex, bool, bFromSweep, const FHitResult &, SweepResult);\nこれの UPrimitiveComponent*, OverlappedComponent, AActor*, OtherActor, UPrimitiveComponent*, OtherComp, int32, OtherBodyIndex, bool, bFromSweep, const FHitResult &, SweepResult を参考にして、\nvoid AAuraEffectActor::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\nを定義したわけだ。"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_04.html#問題点",
    "href": "posts/ue5_aura_courses/section_04.html#問題点",
    "title": "section_04",
    "section": "問題点",
    "text": "問題点\n\nDelecateについての勉強\nC++のマクロの文法についての勉強"
  },
  {
    "objectID": "posts/at_coder/typical90-06.html",
    "href": "posts/at_coder/typical90-06.html",
    "title": "typical90-06",
    "section": "",
    "text": "問題リンク"
  },
  {
    "objectID": "posts/at_coder/typical90-06.html#概要",
    "href": "posts/at_coder/typical90-06.html#概要",
    "title": "typical90-06",
    "section": "概要",
    "text": "概要\n失敗した解き方\nコメントの中でやった通りのやり方。これだと計算量が \\(k^{n}\\) になってしまうためにデカいテストデータでは通らなかった。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        k: usize,\n        s: String,\n    }\n\n    let vec_str = s.chars().into_iter().collect::&lt;Vec&lt;char&gt;&gt;();\n    let mut vec_str_to_usize = vec_str\n        .clone()\n        .into_iter()\n        .map(|c| c.to_digit(36).unwrap() as usize)\n        .collect::&lt;Vec&lt;usize&gt;&gt;();\n\n    // 例えば、n=7, k=3, s=abcdefgの場合、\n    // 0,1,2,3,4=n-k の中から最大のものを選んで、で残ったやつから i,i+1,...,n-k+1=3 の中から最大のものを選ぶ。\n    // これから続けて、\n\n    let mut ans = vec![];\n\n    // let first_index = find_biggest_index(vec_str_to_usize.clone(), 0, n - k);\n    // ans.push(vec_str[first_index]);\n    // let second_index = find_biggest_index(vec_str_to_usize.clone(), first_index + 1, n - k + 1);\n\n    let mut now_index = 0;\n    for i in 0..k {\n        if i == 0 {\n            now_index = find_smallest_index(vec_str_to_usize.clone(), 0, n - k);\n        } else {\n            now_index = find_smallest_index(vec_str_to_usize.clone(), now_index + 1, n - k + i);\n        }\n        ans.push(vec_str[now_index]);\n    }\n\n    println!(\"{}\", ans.into_iter().collect::&lt;String&gt;());\n}\n\nfn find_smallest_index(\n    vec_str_to_usize: Vec&lt;usize&gt;,\n    start_index: usize,\n    end_index: usize,\n) -&gt; usize {\n    let mut min = 36;\n    let mut index = 0;\n\n    for i in start_index..end_index + 1 {\n        if min &gt; vec_str_to_usize[i as usize] {\n            min = vec_str_to_usize[i as usize];\n            index = i;\n        }\n    }\n\n    index\n}\nなので別の方法を考える。\n\\(N\\) の長さの文字列の中から一番でかいアルファベットを探して、それが \\(N-K\\) 番目より前にあればOK。その値を上から順に並べていく。これだと計算量は \\(NK\\) になる。けどまだダメ。\nfn find_smallest_index(vec_str_to_usize: Vec&lt;usize&gt;, limit_index: usize) -&gt; usize {\n    for (i, j) in iproduct!(11..36, 0..limit_index) {\n        if vec_str_to_usize[j] == i {\n            return j;\n        }\n    }\n    0\n}\nここで問題となるのが、 \\(\\symscr{O}(10^8)\\) がおおよそ実行時間が2秒であることを考慮すると、 \\(NK\\) だとダメだということ。なので \\(N\\) か \\(K\\) を \\(1\\) にするような方法を考えたとき、Stringを整理して、 \\(N\\) 回の計算を終えたらすぐに \\(K\\) 回の計算をすれば終わるようなデータベースを準備すればいい。これだと計算量は \\(N+K\\) になるので、解決できる。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        k: usize,\n        s: String,\n    }\n\n    let vec_str = s.chars().into_iter().collect::&lt;Vec&lt;char&gt;&gt;();\n    let mut vec_str_to_usize = vec_str\n        .clone()\n        .into_iter()\n        .map(|c| c.to_digit(36).unwrap() as usize - 10)\n        .collect::&lt;Vec&lt;usize&gt;&gt;();\n\n    let mut ans = vec![];\n\n    let r = generate_r(vec_str_to_usize.clone());\n\n    let mut position = -1;\n\n    for i in 0..k {\n        for j in 0..26 {\n            let tmp = r[(position + 1) as usize][j];\n            if tmp != -1 && n - tmp as usize &gt;= k - i {\n                ans.push(char::from_digit((j + 10) as u32, 36).unwrap());\n                position = tmp as isize;\n                break;\n            }\n        }\n    }\n\n    println!(\"{}\", ans.into_iter().collect::&lt;String&gt;());\n}\n\n// r[i][j]がi桁目の数より右側にjが出現する最小のインデックスを返す\n\nfn generate_r(vec_str_to_usize: Vec&lt;usize&gt;) -&gt; Vec&lt;Vec&lt;isize&gt;&gt; {\n    let mut r: Vec&lt;Vec&lt;isize&gt;&gt; = vec![vec![-1; 26]; vec_str_to_usize.len() + 1];\n\n    for i in (0..vec_str_to_usize.len()).rev() {\n        for j in 0..26 {\n            if vec_str_to_usize[i] == j {\n                r[i][j] = i as isize;\n            } else {\n                r[i][j] = r[i + 1][j];\n            }\n        }\n    }\n\n    r\n}\n困難は分割せよっていう話があるが、これは困難を積集合として分割してはならないという教訓を与えてくれた。"
  },
  {
    "objectID": "posts/at_coder/typical90-06.html#発見",
    "href": "posts/at_coder/typical90-06.html#発見",
    "title": "typical90-06",
    "section": "発見",
    "text": "発見\n\n実行時間の目安\n\\(\\symscr{O}(10^8)\\) がおおよそ実行時間が2秒である。これが大体どのコンテストでもリミッターになってるらしい。\n\n\n問題"
  },
  {
    "objectID": "posts/at_coder/typical90-06.html#問題点",
    "href": "posts/at_coder/typical90-06.html#問題点",
    "title": "typical90-06",
    "section": "問題点",
    "text": "問題点"
  },
  {
    "objectID": "posts/at_coder/typical90-04.html",
    "href": "posts/at_coder/typical90-04.html",
    "title": "typical90-04",
    "section": "",
    "text": "問題リンク"
  },
  {
    "objectID": "posts/at_coder/typical90-04.html#概要",
    "href": "posts/at_coder/typical90-04.html#概要",
    "title": "typical90-04",
    "section": "概要",
    "text": "概要\n簡単な問題。\n前処理をした方が良い、くらいしか話すことがない。\nuse itertools::iproduct;\nuse nalgebra::DMatrix;\nuse proconio::input;\n\nfn main() {\n    input! {\n        h: usize,\n        w: usize,\n        b: [usize; w * h],\n    }\n    \n    let mat = DMatrix::from_row_slice(h, w, &b);\n    \n    let row_sum = mat.clone().row_sum();\n    let col_sum = mat.clone().column_sum();\n    \n    for j in 0..w {\n        let tmp = row_sum[j] + col_sum[0] - mat[(0, j)];\n\n        if j == 0 {\n            print!(\"{}\", tmp);\n        } else {\n            print!(\" {}\", tmp);\n        }\n    }\n\n    for (i, j) in iproduct!(1..h, 0..w) {\n        let tmp = row_sum[j] + col_sum[i] - mat[(i, j)];\n        \n        if j == 0 {\n            print!(\"\\n{}\", tmp);\n        } else {\n            print!(\" {}\", tmp);\n        }\n    }\n    \n}"
  },
  {
    "objectID": "posts/at_coder/typical90-04.html#発見",
    "href": "posts/at_coder/typical90-04.html#発見",
    "title": "typical90-04",
    "section": "発見",
    "text": "発見\n\nnalgebraの使い方\nuse nalgebra::DMatrix;\n\nfn main() {\n    let mat = DMatrix::from_row_slice(2, 3, &[1, 2, 3, 4, 5, 6]);\n    assert_eq!(mat[(0, 0)], 1);\n    assert_eq!(mat[(0, 1)], 2);\n\n    let mat_zero = DMatrix::zeros(2, 3);\n    assert_eq!(mat_zero[(0, 0)], 0);\n\n    let elm = 10;\n    let mat_elm = DMatrix::from_element(2, 3, elm);\n    assert_eq!(mat_elm[(0, 0)], elm);\n\n    let mat_vec = DMatrix::from_vec(4, 3, vec![1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]);\n    assert_eq!(mat_vec[(0, 0)], 1.0);\n\n    let mat_macro = matrix![1, 2, 3;\n                4, 5, 6;\n                7, 8, 9];\n    assert_eq!(mat_macro[(2, 1)], 8);\n}"
  },
  {
    "objectID": "posts/at_coder/typical90-04.html#問題点",
    "href": "posts/at_coder/typical90-04.html#問題点",
    "title": "typical90-04",
    "section": "問題点",
    "text": "問題点"
  },
  {
    "objectID": "posts/at_coder/typical90-11.html",
    "href": "posts/at_coder/typical90-11.html",
    "title": "typical90-11",
    "section": "",
    "text": "問題リンク\nDPの問題です。慣れたものだね。\nuse itertools::iproduct;\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        mut dcs: [(usize, usize, usize); n],\n    }\n\n    // 締切日を降順にソート\n    dcs.sort_by(|a, b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)).then(b.2.cmp(&a.2)));\n\n    // dp[i][j]: i問題目まで考えて、それまでの合計仕事日数がjの時の、報酬の最大値\n    let mut dp = vec![vec![0; 5001]; n + 1];\n\n    for (i, j) in iproduct!(0..n, 0..5001) {\n        // i問題目を解く場合\n        if j + dcs[i].1 &lt;= dcs[i].0 {\n            dp[i + 1][j + dcs[i].1] = dp[i + 1][j + dcs[i].1].max(dp[i][j] + dcs[i].2);\n        }\n        // i問題目を解かない場合\n        dp[i + 1][j] = dp[i + 1][j].max(dp[i][j]);\n    }\n\n    println!(\"{}\", dp[n].iter().max().unwrap());\n\n}"
  },
  {
    "objectID": "posts/at_coder/typical90-11.html#概要",
    "href": "posts/at_coder/typical90-11.html#概要",
    "title": "typical90-11",
    "section": "",
    "text": "問題リンク\nDPの問題です。慣れたものだね。\nuse itertools::iproduct;\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        mut dcs: [(usize, usize, usize); n],\n    }\n\n    // 締切日を降順にソート\n    dcs.sort_by(|a, b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)).then(b.2.cmp(&a.2)));\n\n    // dp[i][j]: i問題目まで考えて、それまでの合計仕事日数がjの時の、報酬の最大値\n    let mut dp = vec![vec![0; 5001]; n + 1];\n\n    for (i, j) in iproduct!(0..n, 0..5001) {\n        // i問題目を解く場合\n        if j + dcs[i].1 &lt;= dcs[i].0 {\n            dp[i + 1][j + dcs[i].1] = dp[i + 1][j + dcs[i].1].max(dp[i][j] + dcs[i].2);\n        }\n        // i問題目を解かない場合\n        dp[i + 1][j] = dp[i + 1][j].max(dp[i][j]);\n    }\n\n    println!(\"{}\", dp[n].iter().max().unwrap());\n\n}"
  },
  {
    "objectID": "posts/at_coder/typical90-02.html",
    "href": "posts/at_coder/typical90-02.html",
    "title": "typical90-02",
    "section": "",
    "text": "問題リンク\n(())などをランダムウォークのように考えると、常に＋の部分にいて、最終的には必ず0に戻ってくることがわかる。\n効率のいい回答だったのは、回帰関数で解いているところ。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n : i32,\n    }\n\n    if n % 2 == 1 {\n        return;\n    }\n\n    let mut cs = Vec::new();\n    let mut answer = Vec::new();\n    let mut left = n / 2;\n    let mut right = n / 2;\n\n    recursive(&mut cs, &mut left, &mut right, &mut answer);\n\n    for i in 0..answer.len() {\n        println!(\"{}\", answer[i]);\n    }\n}\n\nfn recursive(cs: &mut Vec&lt;char&gt;, left: &mut i32, right: &mut i32, answer: &mut Vec&lt;String&gt;) {\n    if *left == 0 && *right == 0 {\n        answer.push(cs.iter().collect());\n        return;\n    }\n\n    if *left &gt; 0 {\n        *left -= 1;\n        cs.push('(');\n        recursive(cs, left, right, answer);\n        cs.pop();\n        *left += 1;\n    }\n\n    if *right &gt; 0 && *left &lt; *right {\n        *right -= 1;\n        cs.push(')');\n        recursive(cs, left, right, answer);\n        cs.pop();\n        *right += 1;\n    }\n}\n発想としては、00001111,00010111,…のような二進数を作っていくことを考えていくところ。で、0の数を超えないように1をappendしていくわけだ。辞書式に並べていくわけだから、最初に0を入れて、後で1を入れれば、自ずと辞書式に並べられる。"
  },
  {
    "objectID": "posts/at_coder/typical90-02.html#概要",
    "href": "posts/at_coder/typical90-02.html#概要",
    "title": "typical90-02",
    "section": "",
    "text": "問題リンク\n(())などをランダムウォークのように考えると、常に＋の部分にいて、最終的には必ず0に戻ってくることがわかる。\n効率のいい回答だったのは、回帰関数で解いているところ。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n : i32,\n    }\n\n    if n % 2 == 1 {\n        return;\n    }\n\n    let mut cs = Vec::new();\n    let mut answer = Vec::new();\n    let mut left = n / 2;\n    let mut right = n / 2;\n\n    recursive(&mut cs, &mut left, &mut right, &mut answer);\n\n    for i in 0..answer.len() {\n        println!(\"{}\", answer[i]);\n    }\n}\n\nfn recursive(cs: &mut Vec&lt;char&gt;, left: &mut i32, right: &mut i32, answer: &mut Vec&lt;String&gt;) {\n    if *left == 0 && *right == 0 {\n        answer.push(cs.iter().collect());\n        return;\n    }\n\n    if *left &gt; 0 {\n        *left -= 1;\n        cs.push('(');\n        recursive(cs, left, right, answer);\n        cs.pop();\n        *left += 1;\n    }\n\n    if *right &gt; 0 && *left &lt; *right {\n        *right -= 1;\n        cs.push(')');\n        recursive(cs, left, right, answer);\n        cs.pop();\n        *right += 1;\n    }\n}\n発想としては、00001111,00010111,…のような二進数を作っていくことを考えていくところ。で、0の数を超えないように1をappendしていくわけだ。辞書式に並べていくわけだから、最初に0を入れて、後で1を入れれば、自ずと辞書式に並べられる。"
  },
  {
    "objectID": "posts/at_coder/typical90-02.html#発見",
    "href": "posts/at_coder/typical90-02.html#発見",
    "title": "typical90-02",
    "section": "発見",
    "text": "発見\n\nString Str Vecの相互変換\n\nstr と String の違い\n\nstr is a “String” slice.\n\nSlice is a pointer to a block of memory.\nSlice is immutable.\nIf you make a string via “string” then it is &str.\n\nString is type of “String”.\n\nString is a heap-allocated string. It is growable, mutable like vec and UTF-8 encoded.\n\n\n\n\nString -&gt; str\n    let s: String = \"abc\".to_string();\n    let ss: &str = &s;\n    println!(\"{}\", &ss); // → abc\n\n\nchar -&gt; String\n    let c: char = 'a';\n    let cs: String = c.to_string();\n    println!(\"{}\", &cs); // → a\n\n\nVec -&gt; String\n    let cs: Vec&lt;char&gt; = vec!['a', 'b', 'c'];\n    let s: String = cs.iter().collect();\n    println!(\"{}\", &s); // → abc\n\n\nString -&gt; Vec\n    let s: String = \"abc\".to_string();\n    let cs: Vec&lt;char&gt; = s.chars().collect();\n    println!(\"{:?}\", &cs); // → ['a', 'b', 'c']\n\n\n\nBinaryの話。\nfn main() {\n    let x = 13;\n\n    // bが2進数に変換という意味。020は0を20桁まで入れるという意味。\n    let s = format!(\"{:020b}\", x);\n\n    println!(\"{}\", s);\n}"
  },
  {
    "objectID": "posts/at_coder/typical90-02.html#問題点",
    "href": "posts/at_coder/typical90-02.html#問題点",
    "title": "typical90-02",
    "section": "問題点",
    "text": "問題点\n\nnext_permutation??\nユーザー解説の内容が理解できなかった。\nnext_permutationなんとかって言ってたけど、意味がわからんかった。"
  },
  {
    "objectID": "posts/at_coder/template.html#発見",
    "href": "posts/at_coder/template.html#発見",
    "title": "template",
    "section": "発見",
    "text": "発見\n\n問題"
  },
  {
    "objectID": "posts/at_coder/template.html#問題点",
    "href": "posts/at_coder/template.html#問題点",
    "title": "template",
    "section": "問題点",
    "text": "問題点"
  },
  {
    "objectID": "posts/at_coder/typical90-08.html",
    "href": "posts/at_coder/typical90-08.html",
    "title": "typical90-08",
    "section": "",
    "text": "問題リンク\n計算量の問題で、おそらく多項式時間に収めないといけない。故に数え上げをやるのではなく、漸化式を数値的に解くことになる。\n\\[\nA_i =\n\\begin{pmatrix}\na_{i,0}\\; &: \\; a\\\\\na_{i,1}\\; &: \\; at\\\\\na_{i,2}\\; &: \\; atc\\\\\na_{i,3}\\; &: \\; atco\\\\\na_{i,4}\\; &: \\; atcod\\\\\na_{i,5}\\; &: \\; atcode\\\\\na_{i,6}\\; &: \\; atcoder\\\\\n\\end{pmatrix}\n\\]\nこんな行列を考えて、それの目的になる項を求めていく。漸化式は次のようなルールに従う。\n\\[\na_{i+1,k} =\n\\begin{cases}\na_{i,k} &\\text{$k$番目の文字じゃなかったら}\\\\\na_{i,k} + a_{i,k-1}　&\\text{$k$番目の文字だったら}\n\\end{cases}\n\\]\nコードに落とし込めば次のようになる。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        s: String,\n    }\n    let modular = 1_000_000_007;\n\n    let vec_str = s.chars().collect::&lt;Vec&lt;char&gt;&gt;();\n\n    let mut ans = vec![0; 7];\n\n    for i in vec_str {\n        match i {\n            'a' =&gt; ans[0] = (ans[0] + 1) % modular,\n            't' =&gt; ans[1] = (ans[1] + ans[0]) % modular,\n            'c' =&gt; ans[2] = (ans[2] + ans[1]) % modular,\n            'o' =&gt; ans[3] = (ans[3] + ans[2]) % modular,\n            'd' =&gt; ans[4] = (ans[4] + ans[3]) % modular,\n            'e' =&gt; ans[5] = (ans[5] + ans[4]) % modular,\n            'r' =&gt; ans[6] = (ans[6] + ans[5]) % modular,\n            _ =&gt; (),\n        }\n    }\n\n    println!(\"{}\", ans[6] % 1_000_000_007);\n}\nこうかなり慣れてきたのか、30分ちょっとで解き切れるようになった。"
  },
  {
    "objectID": "posts/at_coder/typical90-08.html#概要",
    "href": "posts/at_coder/typical90-08.html#概要",
    "title": "typical90-08",
    "section": "",
    "text": "問題リンク\n計算量の問題で、おそらく多項式時間に収めないといけない。故に数え上げをやるのではなく、漸化式を数値的に解くことになる。\n\\[\nA_i =\n\\begin{pmatrix}\na_{i,0}\\; &: \\; a\\\\\na_{i,1}\\; &: \\; at\\\\\na_{i,2}\\; &: \\; atc\\\\\na_{i,3}\\; &: \\; atco\\\\\na_{i,4}\\; &: \\; atcod\\\\\na_{i,5}\\; &: \\; atcode\\\\\na_{i,6}\\; &: \\; atcoder\\\\\n\\end{pmatrix}\n\\]\nこんな行列を考えて、それの目的になる項を求めていく。漸化式は次のようなルールに従う。\n\\[\na_{i+1,k} =\n\\begin{cases}\na_{i,k} &\\text{$k$番目の文字じゃなかったら}\\\\\na_{i,k} + a_{i,k-1}　&\\text{$k$番目の文字だったら}\n\\end{cases}\n\\]\nコードに落とし込めば次のようになる。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        s: String,\n    }\n    let modular = 1_000_000_007;\n\n    let vec_str = s.chars().collect::&lt;Vec&lt;char&gt;&gt;();\n\n    let mut ans = vec![0; 7];\n\n    for i in vec_str {\n        match i {\n            'a' =&gt; ans[0] = (ans[0] + 1) % modular,\n            't' =&gt; ans[1] = (ans[1] + ans[0]) % modular,\n            'c' =&gt; ans[2] = (ans[2] + ans[1]) % modular,\n            'o' =&gt; ans[3] = (ans[3] + ans[2]) % modular,\n            'd' =&gt; ans[4] = (ans[4] + ans[3]) % modular,\n            'e' =&gt; ans[5] = (ans[5] + ans[4]) % modular,\n            'r' =&gt; ans[6] = (ans[6] + ans[5]) % modular,\n            _ =&gt; (),\n        }\n    }\n\n    println!(\"{}\", ans[6] % 1_000_000_007);\n}\nこうかなり慣れてきたのか、30分ちょっとで解き切れるようになった。"
  },
  {
    "objectID": "posts/at_coder/typical90-08.html#発見",
    "href": "posts/at_coder/typical90-08.html#発見",
    "title": "typical90-08",
    "section": "発見",
    "text": "発見\n\n計算時にModularをかけておく。\nでなければ、オーバーフローして変な値になる。普通はコンパイルエラーが起きるのだが、この場合は起きなかった。おそらくある程度複雑なプログラムには対応できないのだろう。\n\n\n問題"
  },
  {
    "objectID": "posts/at_coder/typical90-08.html#問題点",
    "href": "posts/at_coder/typical90-08.html#問題点",
    "title": "typical90-08",
    "section": "問題点",
    "text": "問題点"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-3.html",
    "href": "posts/journal/2023-11/2023-11-3.html",
    "title": "2023-11-03",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-3.html#今日の予定の完成度",
    "href": "posts/journal/2023-11/2023-11-3.html#今日の予定の完成度",
    "title": "2023-11-03",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-3.html#今日の計画",
    "href": "posts/journal/2023-11/2023-11-3.html#今日の計画",
    "title": "2023-11-03",
    "section": "今日の計画",
    "text": "今日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n0\n\n午後前\n\n\nAtCoder\n0\n\n午後後\n\n\nDrawing\n0\n\n夜まで\n\n\nGym\n0\nThis is in the first priority\n定時間\n\n\nCleaning\n0\n\n不定時"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-3.html#明日の計画",
    "href": "posts/journal/2023-11/2023-11-3.html#明日の計画",
    "title": "2023-11-03",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n8\n\n午後前\n\n\nAtCoder\n4\n\n午後後\n\n\nDrawing\n2\n\n夜まで\n\n\nGym\n2\nThis is in the first priority\n定時間\n\n\nCleaning\n1\n\n不定時"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-3.html#日記",
    "href": "posts/journal/2023-11/2023-11-3.html#日記",
    "title": "2023-11-03",
    "section": "日記",
    "text": "日記\n数日間記録を残していなかった。マジでずーっとゲームしてた。\nこのままだとダメなので、このままではダメと思います。（進次郎構文）\n真面目に夜からだけどしっかりとペースを取り戻そう。\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-25.html",
    "href": "posts/journal/2023-11/2023-11-25.html",
    "title": "2023-11-25",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-25.html#今日の予定の完成度",
    "href": "posts/journal/2023-11/2023-11-25.html#今日の予定の完成度",
    "title": "2023-11-25",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-25.html#今日の計画",
    "href": "posts/journal/2023-11/2023-11-25.html#今日の計画",
    "title": "2023-11-25",
    "section": "今日の計画",
    "text": "今日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n6\n\n午後前\n\n\nAtCoder\n1\n\n午後後\n\n\nDrawing\n0\n\n夜まで\n\n\nGym\n0\nThis is in the first priority\n定時間\n\n\nCleaning\n1\n\n不定時"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-25.html#明日の計画",
    "href": "posts/journal/2023-11/2023-11-25.html#明日の計画",
    "title": "2023-11-25",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n8\n\n午後前\n\n\nAtCoder\n4\n\n午後後\n\n\nDrawing\n2\n\n夜まで\n\n\nGym\n2\nThis is in the first priority\n定時間\n\n\nCleaning\n1\n\n不定時"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-09.html",
    "href": "posts/journal/2023-10/2023-10-09.html",
    "title": "2023-10-09",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-09.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-09.html#今日の予定の完成度",
    "title": "2023-10-09",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-09.html#日記",
    "href": "posts/journal/2023-10/2023-10-09.html#日記",
    "title": "2023-10-09",
    "section": "日記",
    "text": "日記\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-17.html",
    "href": "posts/journal/2023-10/2023-10-17.html",
    "title": "2023-10-17",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-17.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-17.html#今日の予定の完成度",
    "title": "2023-10-17",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-17.html#今日の計画",
    "href": "posts/journal/2023-10/2023-10-17.html#今日の計画",
    "title": "2023-10-17",
    "section": "今日の計画",
    "text": "今日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n0\n\n14:00\n\n\nAtCoder\n0\n\n16:30\n\n\nDrawing\n0\n\n18:00\n\n\nGym\n0\nThis is in the first priority\n21:30\n\n\nCleaning\n0\n\n22:30"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-17.html#明日の計画",
    "href": "posts/journal/2023-10/2023-10-17.html#明日の計画",
    "title": "2023-10-17",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n8\n\n14:00\n\n\nAtCoder\n4\n\n16:30\n\n\nDrawing\n2\n\n18:00\n\n\nGym\n2\nThis is in the first priority\n21:30\n\n\nCleaning\n1\n\n22:30"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-17.html#日記",
    "href": "posts/journal/2023-10/2023-10-17.html#日記",
    "title": "2023-10-17",
    "section": "日記",
    "text": "日記\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-14.html",
    "href": "posts/journal/2023-10/2023-10-14.html",
    "title": "2023-10-14",
    "section": "",
    "text": "ダメみたいですね。\n\n\n\nリマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-14.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-14.html#今日の予定の完成度",
    "title": "2023-10-14",
    "section": "",
    "text": "ダメみたいですね。\n\n\n\nリマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-14.html#明日の計画",
    "href": "posts/journal/2023-10/2023-10-14.html#明日の計画",
    "title": "2023-10-14",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\n予定\n駒数\n備考\n時刻\n\n\n\n\nUE5\n8\n流石にSec3はある程度進める\n1400まで\n\n\nAtCoder\n4\n問題1個は進める\n1630まで\n\n\nお絵描き\n2\n長くやりすぎない\n1800まで\n\n\nジム\n2\n移動含めて２時間程度だろうけど、余裕を持とう\n2130まで\n\n\n掃除\n1\n25分だけでもいいからやろう\n2230まで"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-14.html#日記",
    "href": "posts/journal/2023-10/2023-10-14.html#日記",
    "title": "2023-10-14",
    "section": "日記",
    "text": "日記\n明日からはマジでしっかり時間を管理しないといけなさそうだ。マジで何もしてねえや。\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-11.html",
    "href": "posts/journal/2023-10/2023-10-11.html",
    "title": "2023-10-11",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\n\n記事の更新もした\n\nAtCoderを進める\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-11.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-11.html#今日の予定の完成度",
    "title": "2023-10-11",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\n\n記事の更新もした\n\nAtCoderを進める\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-11.html#日記",
    "href": "posts/journal/2023-10/2023-10-11.html#日記",
    "title": "2023-10-11",
    "section": "日記",
    "text": "日記\n特に書くこともないし眠いので寝る。\n昼間はやたらと暑くてしんどかった。明日も暑かったら流石にエアコンをつけようかな。\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n500kcal\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-12.html",
    "href": "posts/journal/2023-10/2023-10-12.html",
    "title": "2023-10-12",
    "section": "",
    "text": "朝、目覚ましが鳴らなかった"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-12.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-12.html#今日の予定の完成度",
    "title": "2023-10-12",
    "section": "今日の予定の完成度",
    "text": "今日の予定の完成度\n\n最重要課題\n\nリマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\n[x023-] AtCoderを進める\n\n\n\n課題\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-12.html#日記",
    "href": "posts/journal/2023-10/2023-10-12.html#日記",
    "title": "2023-10-12",
    "section": "日記",
    "text": "日記\nHelixなるものを使用し始めようと思う。思ったがやめた。結局あれじゃん。NeoVim使えばいいじゃん。\n収容所のページ何をするかまだ決まらず。\nあまり実りのない１日だった。明日はしっかり時間管理をしよう。\n明日からお絵描きをルーティンに入れようかな。\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/univ_lecs/材料相平衡論.html",
    "href": "posts/univ_lecs/材料相平衡論.html",
    "title": "材料相平衡論",
    "section": "",
    "text": "過去問の解答があるので概ね問題ないと思われますが、2021年の(5)の3に問題の誤りがあり、そのことについて図示しました。\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/univ_lecs/材料速度論.html",
    "href": "posts/univ_lecs/材料速度論.html",
    "title": "材料速度論",
    "section": "",
    "text": "軽いまとめと問題の過去問を手書きで解いてます。\nTeXにまとめるのは面倒でした。\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/univ_lecs/材料量子力学.html",
    "href": "posts/univ_lecs/材料量子力学.html",
    "title": "材料量子力学",
    "section": "",
    "text": "過去問を解いていく。手書きです。"
  },
  {
    "objectID": "posts/univ_lecs/材料量子力学.html#section",
    "href": "posts/univ_lecs/材料量子力学.html#section",
    "title": "材料量子力学",
    "section": "2021",
    "text": "2021"
  },
  {
    "objectID": "posts/univ_lecs/材料量子力学.html#section-1",
    "href": "posts/univ_lecs/材料量子力学.html#section-1",
    "title": "材料量子力学",
    "section": "2019",
    "text": "2019"
  },
  {
    "objectID": "posts/univ_lecs/材料量子力学.html#section-2",
    "href": "posts/univ_lecs/材料量子力学.html#section-2",
    "title": "材料量子力学",
    "section": "2015",
    "text": "2015"
  },
  {
    "objectID": "posts/univ_lecs/材料量子力学.html#section-3",
    "href": "posts/univ_lecs/材料量子力学.html#section-3",
    "title": "材料量子力学",
    "section": "2009",
    "text": "2009"
  },
  {
    "objectID": "posts/univ_lecs/材料力学.html",
    "href": "posts/univ_lecs/材料力学.html",
    "title": "統計力学",
    "section": "",
    "text": "作ったらみんなが喜ぶと聞いて．\n\\[\\require{physics}\\]\n\n\n\nレオロジーとは、(変形と流動) の学問であり、(ソフトマター)と呼ばれる固体と液体の中間的な性質をもつ材料を対象とする。\n固体の示す性質を(弾性)、液体の示す性質を(粘性)と呼ぶ。その二つをわけるのは、簡単には(かたち)を忘れるかどうかである。\nエネルギーの観点からは、固体は変形によるエネルギーを(貯蔵)する一方で液体はエネルギーを(散逸)する。\nスライムやゲルは、(時間)によって固体と液体の中間的な性質を示す(粘弾性)体である。\nマヨネーズや歯磨き粉は、(加える変形量)によって固体と液体の中間的な性質を示す(塑性)体である。\nレオロジー特性を利用した様々な材料が、わたしたちの身の周りに存在する (例:化粧品、防振ゴム、、、、)。\n\n\n\n\n\n材料の力学を扱う上で、力と変形の関係は試料形状によらない必要がある。このため、規格化した力、変形量として(応力)と(ひずみ)が用いられる。\n一軸伸張変形を特徴づけるパラメータとして(ヤング)率が、ずり変形を特徴づけるパラメータとして(剛性)率がある。これらは、変形前後の体 積変化を示す(ポアソン比)で結び付けられており、等体積変形下におい て(3)倍の関係にある。\nより一般的な表記として、(テンソル)を用いることができる。対称性を考えるとこのテンソルには、(6)個の独立変数が存在する。\n純粋な変形の効果を考えるため、(フィンガーテンソル)が使われる。さらに、座標系によらない変数として、(不変量)が用いられる。\n\n\n\n\n\n材料の粘弾性は、(レオメータ)という装置を用いて、種々の変形を加えることで評価できる。\n粘弾性評価方法としては、一定ひずみを加え応力の時間変化を観察する(クリープ)、正弦ひずみを加える(動的粘弾性)がある。\nそれぞれについて、(緩和弾性率)、(クリープコンプライアンス)、(貯蔵・損失弾性率)を用いることで、粘弾性の定量的な議論ができる。 線形粘弾性の範囲において、これらの関数は等価な情報を有する。\n任意の変形履歴を受けた場合、ある時間における応力 (ひずみ) は過去の時刻における微小時間内に誘起した応力(ひずみ)の総和として記述できることを(Boltzmannの重畳原理)と呼び、この加成性が成り立つ範囲 を線形粘弾性と呼ぶ。\n実際の成形加工、実用上は(非線形)粘弾性が重要となる場面もある。\n\n\n\n\n\n高分子は、分子が(共有結合)によって連結したひも状の物質である。\n高分子は、ポリエチレンのような(結晶)性高分子とポリスチレンのような(非晶)性高分子に大別できる。(非晶)性高分子には、分子運動性の違 いによって、(ガラス)状態と(ゴム)状態が存在する。(ゴム)状態の高分子が示すソフトな弾性を(ゴム)弾性と呼ぶ。\n(ゴム)弾性の特徴は、\n\n金属と比べ(小さい力で大きく変形)する\n温度を上げると弾性率が(増加)する\n急激に伸長すると(暖まり)、急激に圧縮すると(冷える) - 応力ー延伸比曲線が(S)字型\n\n熱力学的な解析から、ゴム弾性は、金属の示す(エネルギー)弾性と異なり、 (エントロピー)の寄与が支配的であることがわかる。\n\n\n\n\n\nゴム弾性は、(エントロピー)由来の寄与が支配的である。\n高分子一本鎖の弾性は、(ガウス)統計を用いることで、定量的に議論することが可能である。\n網目を単純化した(自由連結鎖)モデルを用いることで、ゴムの非線形挙動をある程度、記述可能である。\nゴム弾性の式に基づくと、弾性率は(部分鎖密度)に比例することがわかる。\n架橋点数や(部分鎖)密度は、パーコレーションモデルなどで見積もることができ、(\\(G = 2pCk_BT\\))のように予測される。\n高分子絡み合い溶液の場合、弾性率は(濃度)のみで規定される。\n\n\n\n\n\n高分子の粘弾性緩和は、(分子ダイナミックス)を反映する。\n非絡み合い系の粘弾性緩和は分子量に対して(2)乗の関係を示す。( バネ・ビーズ ) モデルを用いることで、粘弾性緩和挙動を予測可能である。Boltzmannの重畳原理より粘度の分子量依存性は(高分子のからみあい ) と予測される。\n絡み合った高分子の粘弾性緩和は、濃度・分子量に対して( ) の関係を示す。絡んだ周囲の鎖の影響で、分子は一方向に拡散する( 熱 )運動によって緩和が起こる。(管 )モデルを用いる ことで、絡み合い高分子の粘弾性は記述可能である。\n分岐が入ると( レプテーション運動（一次元運動） )が抑制され、( 鎖の収縮運動 )によってのみ緩和が 進行するため、ダイナミクスが遅延する。\n高度に分岐すると、系全体が固体として振る舞うゲルになる。 ゾルとゲルの境目では、( 緩和時間が発散)の関係が見られ、( Winter -Chambon )則と呼ばれる。"
  },
  {
    "objectID": "posts/univ_lecs/材料力学.html#section",
    "href": "posts/univ_lecs/材料力学.html#section",
    "title": "統計力学",
    "section": "",
    "text": "レオロジーとは、(変形と流動) の学問であり、(ソフトマター)と呼ばれる固体と液体の中間的な性質をもつ材料を対象とする。\n固体の示す性質を(弾性)、液体の示す性質を(粘性)と呼ぶ。その二つをわけるのは、簡単には(かたち)を忘れるかどうかである。\nエネルギーの観点からは、固体は変形によるエネルギーを(貯蔵)する一方で液体はエネルギーを(散逸)する。\nスライムやゲルは、(時間)によって固体と液体の中間的な性質を示す(粘弾性)体である。\nマヨネーズや歯磨き粉は、(加える変形量)によって固体と液体の中間的な性質を示す(塑性)体である。\nレオロジー特性を利用した様々な材料が、わたしたちの身の周りに存在する (例:化粧品、防振ゴム、、、、)。"
  },
  {
    "objectID": "posts/univ_lecs/材料力学.html#section-1",
    "href": "posts/univ_lecs/材料力学.html#section-1",
    "title": "統計力学",
    "section": "",
    "text": "材料の力学を扱う上で、力と変形の関係は試料形状によらない必要がある。このため、規格化した力、変形量として(応力)と(ひずみ)が用いられる。\n一軸伸張変形を特徴づけるパラメータとして(ヤング)率が、ずり変形を特徴づけるパラメータとして(剛性)率がある。これらは、変形前後の体 積変化を示す(ポアソン比)で結び付けられており、等体積変形下におい て(3)倍の関係にある。\nより一般的な表記として、(テンソル)を用いることができる。対称性を考えるとこのテンソルには、(6)個の独立変数が存在する。\n純粋な変形の効果を考えるため、(フィンガーテンソル)が使われる。さらに、座標系によらない変数として、(不変量)が用いられる。"
  },
  {
    "objectID": "posts/univ_lecs/材料力学.html#section-2",
    "href": "posts/univ_lecs/材料力学.html#section-2",
    "title": "統計力学",
    "section": "",
    "text": "材料の粘弾性は、(レオメータ)という装置を用いて、種々の変形を加えることで評価できる。\n粘弾性評価方法としては、一定ひずみを加え応力の時間変化を観察する(クリープ)、正弦ひずみを加える(動的粘弾性)がある。\nそれぞれについて、(緩和弾性率)、(クリープコンプライアンス)、(貯蔵・損失弾性率)を用いることで、粘弾性の定量的な議論ができる。 線形粘弾性の範囲において、これらの関数は等価な情報を有する。\n任意の変形履歴を受けた場合、ある時間における応力 (ひずみ) は過去の時刻における微小時間内に誘起した応力(ひずみ)の総和として記述できることを(Boltzmannの重畳原理)と呼び、この加成性が成り立つ範囲 を線形粘弾性と呼ぶ。\n実際の成形加工、実用上は(非線形)粘弾性が重要となる場面もある。"
  },
  {
    "objectID": "posts/univ_lecs/材料力学.html#section-3",
    "href": "posts/univ_lecs/材料力学.html#section-3",
    "title": "統計力学",
    "section": "",
    "text": "高分子は、分子が(共有結合)によって連結したひも状の物質である。\n高分子は、ポリエチレンのような(結晶)性高分子とポリスチレンのような(非晶)性高分子に大別できる。(非晶)性高分子には、分子運動性の違 いによって、(ガラス)状態と(ゴム)状態が存在する。(ゴム)状態の高分子が示すソフトな弾性を(ゴム)弾性と呼ぶ。\n(ゴム)弾性の特徴は、\n\n金属と比べ(小さい力で大きく変形)する\n温度を上げると弾性率が(増加)する\n急激に伸長すると(暖まり)、急激に圧縮すると(冷える) - 応力ー延伸比曲線が(S)字型\n\n熱力学的な解析から、ゴム弾性は、金属の示す(エネルギー)弾性と異なり、 (エントロピー)の寄与が支配的であることがわかる。"
  },
  {
    "objectID": "posts/univ_lecs/材料力学.html#section-4",
    "href": "posts/univ_lecs/材料力学.html#section-4",
    "title": "統計力学",
    "section": "",
    "text": "ゴム弾性は、(エントロピー)由来の寄与が支配的である。\n高分子一本鎖の弾性は、(ガウス)統計を用いることで、定量的に議論することが可能である。\n網目を単純化した(自由連結鎖)モデルを用いることで、ゴムの非線形挙動をある程度、記述可能である。\nゴム弾性の式に基づくと、弾性率は(部分鎖密度)に比例することがわかる。\n架橋点数や(部分鎖)密度は、パーコレーションモデルなどで見積もることができ、(\\(G = 2pCk_BT\\))のように予測される。\n高分子絡み合い溶液の場合、弾性率は(濃度)のみで規定される。"
  },
  {
    "objectID": "posts/univ_lecs/材料力学.html#section-5",
    "href": "posts/univ_lecs/材料力学.html#section-5",
    "title": "統計力学",
    "section": "",
    "text": "高分子の粘弾性緩和は、(分子ダイナミックス)を反映する。\n非絡み合い系の粘弾性緩和は分子量に対して(2)乗の関係を示す。( バネ・ビーズ ) モデルを用いることで、粘弾性緩和挙動を予測可能である。Boltzmannの重畳原理より粘度の分子量依存性は(高分子のからみあい ) と予測される。\n絡み合った高分子の粘弾性緩和は、濃度・分子量に対して( ) の関係を示す。絡んだ周囲の鎖の影響で、分子は一方向に拡散する( 熱 )運動によって緩和が起こる。(管 )モデルを用いる ことで、絡み合い高分子の粘弾性は記述可能である。\n分岐が入ると( レプテーション運動（一次元運動） )が抑制され、( 鎖の収縮運動 )によってのみ緩和が 進行するため、ダイナミクスが遅延する。\n高度に分岐すると、系全体が固体として振る舞うゲルになる。 ゾルとゲルの境目では、( 緩和時間が発散)の関係が見られ、( Winter -Chambon )則と呼ばれる。"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-10.html",
    "href": "posts/journal/2023-10/2023-10-10.html",
    "title": "2023-10-10",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-10.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-10.html#今日の予定の完成度",
    "title": "2023-10-10",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-10.html#日記",
    "href": "posts/journal/2023-10/2023-10-10.html#日記",
    "title": "2023-10-10",
    "section": "日記",
    "text": "日記\nやっぱ飯を食うと眠くなってしまう。\n生活リズムを崩さないように気をつけていかないと……。\n1日2食くらいがいいのかね？\n話は変わるが、RustをVSCodeで書くように変えようかと思ったが、ダメだ。重たすぎる。その理由はどこから来ているのかは知らないが、おそらくマルチスレッディングに対応しているかどうかによるものだろうか。Zedの方がよほど速いので、そちらを使うことにした。\nJournalはVSCodeで書きながら、ZedでAtcoderをして、RiderでUEを書くという感じになるのかな。めんどくさい。Riderはまあ仕方ないとしても、ZedにQuartoのExtensionを移植できないかなぁ。\n\nダイエット記録\n\n食べたもの\nスーパーで買った広島風お好み焼き風何か\n鍋用野菜＋春雨の鍋\n\n\nジムでの消費カロリー\n0 kcal\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-15.html",
    "href": "posts/journal/2023-10/2023-10-15.html",
    "title": "2023-10-15",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-15.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-15.html#今日の予定の完成度",
    "title": "2023-10-15",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-15.html#今日の計画",
    "href": "posts/journal/2023-10/2023-10-15.html#今日の計画",
    "title": "2023-10-15",
    "section": "今日の計画",
    "text": "今日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n4\nSec3\n14:00\n\n\nAtCoder\n5\nAt least 1 problem\n16:30\n\n\nDrawing\n0\nDo not do too much\n18:00\n\n\nGym\n0\nFirst Priority\n21:30\n\n\nCleaning\n0\nDo at least 25 minutes\n22:30"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-15.html#明日の計画",
    "href": "posts/journal/2023-10/2023-10-15.html#明日の計画",
    "title": "2023-10-15",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n8\nSec3\n14:00\n\n\nAtCoder\n4\nAt least 1 problem\n16:30\n\n\nDrawing\n2\nDo not do too much\n18:00\n\n\nGym\n2\nFirst Priority\n21:30\n\n\nCleaning\n1\nDo at least 25 minutes\n22:30"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-15.html#日記",
    "href": "posts/journal/2023-10/2023-10-15.html#日記",
    "title": "2023-10-15",
    "section": "日記",
    "text": "日記\nPomodoroを使い始めてみた。いつまで続くかはわからないが、まあ頑張ろう！\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-16.html",
    "href": "posts/journal/2023-10/2023-10-16.html",
    "title": "2023-10-16",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-16.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-16.html#今日の予定の完成度",
    "title": "2023-10-16",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-16.html#今日の計画",
    "href": "posts/journal/2023-10/2023-10-16.html#今日の計画",
    "title": "2023-10-16",
    "section": "今日の計画",
    "text": "今日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n4\n\n14:00\n\n\nAtCoder\n2\n\n16:30\n\n\nDrawing\n0\n\n18:00\n\n\nGym\n2\nThis is in the first priority\n21:30\n\n\nCleaning\n0\n\n22:30"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-16.html#明日の計画",
    "href": "posts/journal/2023-10/2023-10-16.html#明日の計画",
    "title": "2023-10-16",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n8\n\n14:00\n\n\nAtCoder\n4\n\n16:30\n\n\nDrawing\n2\n\n18:00\n\n\nGym\n2\nThis is in the first priority\n21:30\n\n\nCleaning\n1\n\n22:30"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-16.html#日記",
    "href": "posts/journal/2023-10/2023-10-16.html#日記",
    "title": "2023-10-16",
    "section": "日記",
    "text": "日記\npyscketcherなるものを見つけた。TikZと比較してどちらの方が使いやすいかを見極めてから、問題を書くのに使おうかな。\n１日の始まりをスーッと頑張り始めたい。\n無茶をせずに、ね。\nあと、小説もルーティンに入れたいのだけど、今のルーティンができてない状態では流石に差し込めないかな。\nてか、最近RiderとRustRoverを使ってて、もはやJetBrainsのIDEがないと生きていけない状態になってきた。学生が終わったら大人しくお金を貢がせてもらうことにしよう。\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-18.html",
    "href": "posts/journal/2023-10/2023-10-18.html",
    "title": "2023-10-23",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-18.html#今日の予定の完成度",
    "href": "posts/journal/2023-10/2023-10-18.html#今日の予定の完成度",
    "title": "2023-10-23",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-18.html#今日の計画",
    "href": "posts/journal/2023-10/2023-10-18.html#今日の計画",
    "title": "2023-10-23",
    "section": "今日の計画",
    "text": "今日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n0\n\n14:00\n\n\nAtCoder\n5\n\n16:30\n\n\nDrawing\n0\n\n18:00\n\n\nGym\n0\nThis is in the first priority\n21:30\n\n\nCleaning\n0\n\n22:30"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-18.html#明日の計画",
    "href": "posts/journal/2023-10/2023-10-18.html#明日の計画",
    "title": "2023-10-23",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n8\n\n14:00\n\n\nAtCoder\n4\n\n16:30\n\n\nDrawing\n2\n\n18:00\n\n\nGym\n2\nThis is in the first priority\n21:30\n\n\nCleaning\n1\n\n22:30"
  },
  {
    "objectID": "posts/journal/2023-10/2023-10-18.html#日記",
    "href": "posts/journal/2023-10/2023-10-18.html#日記",
    "title": "2023-10-23",
    "section": "日記",
    "text": "日記\n\nダイエット記録\n\n食べたもの\n\n\nジムでの消費カロリー\n\n\n体重\n\n\n\nその他"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-24.html",
    "href": "posts/journal/2023-11/2023-11-24.html",
    "title": "2023-11-24",
    "section": "",
    "text": "やっと何か進捗が出せる日になった。\n収容所の自習室もっと使っていこうかな。\nあとケンタッキーを食ったんだが気分悪くなった。もう２度と食いたくない。"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-24.html#今日の予定の完成度",
    "href": "posts/journal/2023-11/2023-11-24.html#今日の予定の完成度",
    "title": "2023-11-24",
    "section": "今日の予定の完成度",
    "text": "今日の予定の完成度\n\n最重要課題\n\nリマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n課題\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-24.html#今日の計画",
    "href": "posts/journal/2023-11/2023-11-24.html#今日の計画",
    "title": "2023-11-24",
    "section": "今日の計画",
    "text": "今日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n6\n\n午後前\n\n\nAtCoder\n3\n\n午後後\n\n\nDrawing\n1\n\n夜まで\n\n\nGym\n0\nThis is in the first priority\n定時間\n\n\nCleaning\n0\n\n不定時"
  },
  {
    "objectID": "posts/journal/2023-11/2023-11-24.html#明日の計画",
    "href": "posts/journal/2023-11/2023-11-24.html#明日の計画",
    "title": "2023-11-24",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n8\n\n午後前\n\n\nAtCoder\n4\n\n午後後\n\n\nDrawing\n2\n\n夜まで\n\n\nGym\n2\nThis is in the first priority\n定時間\n\n\nCleaning\n1\n\n不定時"
  },
  {
    "objectID": "posts/journal/2023-11/template.html",
    "href": "posts/journal/2023-11/template.html",
    "title": "template",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-11/template.html#今日の予定の完成度",
    "href": "posts/journal/2023-11/template.html#今日の予定の完成度",
    "title": "template",
    "section": "",
    "text": "リマインダーの確認\nジムに行く\n掃除をする\nゲームの進捗を産む\nAtCoderを進める\nお絵描きをする\n\n\n\n\n\nUEドキュメントを読み進める\nECサイトの作成を進める"
  },
  {
    "objectID": "posts/journal/2023-11/template.html#今日の計画",
    "href": "posts/journal/2023-11/template.html#今日の計画",
    "title": "template",
    "section": "今日の計画",
    "text": "今日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n0\n\n午後前\n\n\nAtCoder\n0\n\n午後後\n\n\nDrawing\n0\n\n夜まで\n\n\nGym\n0\nThis is in the first priority\n定時間\n\n\nCleaning\n0\n\n不定時"
  },
  {
    "objectID": "posts/journal/2023-11/template.html#明日の計画",
    "href": "posts/journal/2023-11/template.html#明日の計画",
    "title": "template",
    "section": "明日の計画",
    "text": "明日の計画\n\n\n\nPLAN\nUNIT\nEXTRA\nTIME\n\n\n\n\nUE5\n8\n\n午後前\n\n\nAtCoder\n4\n\n午後後\n\n\nDrawing\n2\n\n夜まで\n\n\nGym\n2\nThis is in the first priority\n定時間\n\n\nCleaning\n1\n\n不定時"
  },
  {
    "objectID": "posts/at_coder/typical90-09.html",
    "href": "posts/at_coder/typical90-09.html",
    "title": "typical90-09",
    "section": "",
    "text": "問題リンク\n数学の問題じゃ。\nとりあえず全探索でもギリギリ大丈夫そう。10^10程度だし。いや、でもむずいか？　やってないのでわかんない。\nこの問題は \\(P_i,\\; P_j\\) を固定して最大角となる \\(P_k\\) を探すことになる。幾何的性質で、 \\(P_j\\) を始点として考えてアーム \\(P_jP_k\\) が最もアーム \\(P_iP_j\\) に近づく時の \\(k\\) を考えればいいわけで、そのような \\(k\\) は \\(P_j\\) を始点として考えたアームの偏角をソートすれば見つかる。\n具体的なコードは次のとおり。\nuse num::complex::Complex;\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [[usize; 2]; n],\n    }\n\n    let mut ans = vec![];\n\n    for j in 0..n {\n\n        // Storage は P_j からのその他への点への偏角を格納する\n        let mut storage = vec![];\n\n        for i in 0..n {\n\n            // 同じ点を選んだ時はスキップ\n            if i == j {\n                continue;\n            }\n\n            // 偏角の計算\n            let tmp = Complex::new(a[i][0] as f64, a[i][1] as f64)\n                - Complex::new(a[j][0] as f64, a[j][1] as f64);\n            storage.push(tmp.arg().to_degrees());\n        }\n\n        // 偏角をソート\n        storage.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\n        // P_j, P_i を固定して、作られる角度の最大を探す部分\n        for i in 0..n - 1 {\n\n            // P_j, P_i から作られる角度の反対側に伸びる方向の偏角を計算\n            let mut opp_angle = storage[i] + 180.;\n            if opp_angle &gt;= 180. {\n                opp_angle -= 360.;\n            }\n\n            // 二分探索で偏角の反対側にある点を探す\n            let mut left = 0;\n            let mut right = n - 2;\n            while right - left &gt; 1 {\n                let mid = (left + right) / 2;\n                if storage[mid] &lt;= opp_angle {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n\n            // より大きい偏角を採用\n            let mut tmp_left = storage[i] - storage[left];\n            let mut tmp_right = storage[right] - storage[i];\n            if tmp_left &lt;= 0. {\n                tmp_left += 360.;\n            }\n            if tmp_right &lt;= 0. {\n                tmp_right += 360.;\n            }\n            if tmp_left &gt;= 180. {\n                tmp_left = 360. - tmp_left;\n            }\n            if tmp_right &gt;= 180. {\n                tmp_right = 360. - tmp_right;\n            }\n            ans.push(tmp_left.max(tmp_right));\n        }\n    }\n\n    println!(\n        \"{}\",\n        // P_j, P_i を固定した時の最大の角度を格納した配列の最大値を出力\n        ans.iter().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap()\n    );\n}\n綺麗なコードを書いて載せるなんてやりたいけど、そこまで習熟度があるわけじゃないので、勘弁願いたい。"
  },
  {
    "objectID": "posts/at_coder/typical90-09.html#概要",
    "href": "posts/at_coder/typical90-09.html#概要",
    "title": "typical90-09",
    "section": "",
    "text": "問題リンク\n数学の問題じゃ。\nとりあえず全探索でもギリギリ大丈夫そう。10^10程度だし。いや、でもむずいか？　やってないのでわかんない。\nこの問題は \\(P_i,\\; P_j\\) を固定して最大角となる \\(P_k\\) を探すことになる。幾何的性質で、 \\(P_j\\) を始点として考えてアーム \\(P_jP_k\\) が最もアーム \\(P_iP_j\\) に近づく時の \\(k\\) を考えればいいわけで、そのような \\(k\\) は \\(P_j\\) を始点として考えたアームの偏角をソートすれば見つかる。\n具体的なコードは次のとおり。\nuse num::complex::Complex;\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        a: [[usize; 2]; n],\n    }\n\n    let mut ans = vec![];\n\n    for j in 0..n {\n\n        // Storage は P_j からのその他への点への偏角を格納する\n        let mut storage = vec![];\n\n        for i in 0..n {\n\n            // 同じ点を選んだ時はスキップ\n            if i == j {\n                continue;\n            }\n\n            // 偏角の計算\n            let tmp = Complex::new(a[i][0] as f64, a[i][1] as f64)\n                - Complex::new(a[j][0] as f64, a[j][1] as f64);\n            storage.push(tmp.arg().to_degrees());\n        }\n\n        // 偏角をソート\n        storage.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\n        // P_j, P_i を固定して、作られる角度の最大を探す部分\n        for i in 0..n - 1 {\n\n            // P_j, P_i から作られる角度の反対側に伸びる方向の偏角を計算\n            let mut opp_angle = storage[i] + 180.;\n            if opp_angle &gt;= 180. {\n                opp_angle -= 360.;\n            }\n\n            // 二分探索で偏角の反対側にある点を探す\n            let mut left = 0;\n            let mut right = n - 2;\n            while right - left &gt; 1 {\n                let mid = (left + right) / 2;\n                if storage[mid] &lt;= opp_angle {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n\n            // より大きい偏角を採用\n            let mut tmp_left = storage[i] - storage[left];\n            let mut tmp_right = storage[right] - storage[i];\n            if tmp_left &lt;= 0. {\n                tmp_left += 360.;\n            }\n            if tmp_right &lt;= 0. {\n                tmp_right += 360.;\n            }\n            if tmp_left &gt;= 180. {\n                tmp_left = 360. - tmp_left;\n            }\n            if tmp_right &gt;= 180. {\n                tmp_right = 360. - tmp_right;\n            }\n            ans.push(tmp_left.max(tmp_right));\n        }\n    }\n\n    println!(\n        \"{}\",\n        // P_j, P_i を固定した時の最大の角度を格納した配列の最大値を出力\n        ans.iter().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap()\n    );\n}\n綺麗なコードを書いて載せるなんてやりたいけど、そこまで習熟度があるわけじゃないので、勘弁願いたい。"
  },
  {
    "objectID": "posts/at_coder/typical90-09.html#発見",
    "href": "posts/at_coder/typical90-09.html#発見",
    "title": "typical90-09",
    "section": "発見",
    "text": "発見\n\nf64のソート\nsort_byを使えば楽。\nfn main() {\n    let mut tmp = vec![19.0, 12.9, 1.2];\n    tmp.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    assert_eq!(tmp, [1.2, 12.9, 19.0]);\n}\nこれをそのまま関数にした sort_floats っていう関数もあるけど、nightly-onlyなので使えないかもしれない。"
  },
  {
    "objectID": "posts/at_coder/cargo_compete.html",
    "href": "posts/at_coder/cargo_compete.html",
    "title": "Cargo Compete",
    "section": "",
    "text": "cargo install cargo-compete\ncargo compete init atcoder\ncargo compete new typical90\n\n\n\n```bash cd typical90 cargo compete test 001 cargo compete submit 001 –no-watch"
  },
  {
    "objectID": "posts/at_coder/cargo_compete.html#プロジェクトの設定の仕方",
    "href": "posts/at_coder/cargo_compete.html#プロジェクトの設定の仕方",
    "title": "Cargo Compete",
    "section": "",
    "text": "cargo install cargo-compete\ncargo compete init atcoder\ncargo compete new typical90\n\n\n\n```bash cd typical90 cargo compete test 001 cargo compete submit 001 –no-watch"
  },
  {
    "objectID": "posts/at_coder/typical90-03.html",
    "href": "posts/at_coder/typical90-03.html",
    "title": "typical90-03",
    "section": "",
    "text": "問題リンク"
  },
  {
    "objectID": "posts/at_coder/typical90-03.html#概要",
    "href": "posts/at_coder/typical90-03.html#概要",
    "title": "typical90-03",
    "section": "概要",
    "text": "概要\nDFSを使って解く問題。この問題は、グラフを与えられて、そのグラフの中で最も長い経路を求めれば、その端と端を結んでしまえば求めるサークルができる。\n何よりも苦戦したのは問題文をちゃんと読めてなかったこと。問題文をちゃんと読めていれば、もっと早く解けたはず。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        data: [[usize; 2]; n-1],\n    }\n    \n    let mut graph = vec![vec![]; n];\n\n    for datum in data {\n        graph[datum[0]-1].push(datum[1]-1);\n        graph[datum[1]-1].push(datum[0]-1);\n    }\n\n    let dist_from_0 = solve(graph.clone(), 0);\n    \n    let max_index = dist_from_0.iter().enumerate().max_by_key(|x| x.1).unwrap().0;\n    \n    let dist_from_max = solve(graph.clone(), max_index);\n    \n    println!(\"{}\", dist_from_max.iter().max().unwrap() + 1);\n}\n\nfn solve(graph: Vec&lt;Vec&lt;usize&gt;&gt;,start: usize) -&gt; Vec&lt;isize&gt;{    \n    let mut stack = vec![(start, 0)];\n    let mut dist = vec![-1; graph.len()];\n    dist[start] = 0;\n    \n    while let Some((node, depth)) = stack.pop() {\n        for &next in &graph[node] {\n            if dist[next] != -1 {\n                continue;\n            }\n            dist[next] = depth + 1;\n            stack.push((next, depth + 1));\n        }\n    }\n    \n    return dist;\n}"
  },
  {
    "objectID": "posts/at_coder/typical90-03.html#発見",
    "href": "posts/at_coder/typical90-03.html#発見",
    "title": "typical90-03",
    "section": "発見",
    "text": "発見\n\n複数のループをするときに使う\n// Iterate over the coordinates of a 4 x 4 x 4 grid\n// from (0, 0, 0), (0, 0, 1), .., (0, 1, 0), (0, 1, 1), .. etc until (3, 3, 3)\nfor (i, j, k) in iproduct!(0..4, 0..4, 0..4) {\n   // ..\n}\n\n\nDFSのコードの書き方\nグラフをとりあえず\nVec&lt;Vec&lt;usize&gt;&gt;\nで表現する。\n次に、探索の仕方として、stackを用意して、そこに今現時点の(Node,Depth)を入れておく。そして、stackが空になるまで、stackからtupleを抜き取って行って、次のNodeを探索していく。つまり、stackはいわばNodeにDepthのステッカーを貼っているようなものであり、次に進めれば剥がすということを繰り返している。\n最終的に剥がすことができなかったtupleだけがstuckに積み重なっていくわけである。\n\n\nFind Max Value Index\nlet max_index = data.iter().enumerate().max_by_key(|x| x.1).unwrap().0;\nとかける。\n|x| x.1\nというのはClosureといって、||に挟まれた引数から後ろの数を返す関数のことである。"
  },
  {
    "objectID": "posts/at_coder/typical90-03.html#問題点",
    "href": "posts/at_coder/typical90-03.html#問題点",
    "title": "typical90-03",
    "section": "問題点",
    "text": "問題点"
  },
  {
    "objectID": "posts/at_coder/typical90-01.html",
    "href": "posts/at_coder/typical90-01.html",
    "title": "typical90-01",
    "section": "",
    "text": "問題リンク"
  },
  {
    "objectID": "posts/at_coder/typical90-01.html#概要",
    "href": "posts/at_coder/typical90-01.html#概要",
    "title": "typical90-01",
    "section": "概要",
    "text": "概要\nLearnt Binary Search."
  },
  {
    "objectID": "posts/at_coder/typical90-01.html#発見",
    "href": "posts/at_coder/typical90-01.html#発見",
    "title": "typical90-01",
    "section": "発見",
    "text": "発見\n\nBinary Search\nSearching 0..n is O(n) but searching by binary is O(log n). This makes very big difference."
  },
  {
    "objectID": "posts/at_coder/typical90-01.html#問題点",
    "href": "posts/at_coder/typical90-01.html#問題点",
    "title": "typical90-01",
    "section": "問題点",
    "text": "問題点"
  },
  {
    "objectID": "posts/at_coder/typical90-05.html",
    "href": "posts/at_coder/typical90-05.html",
    "title": "typical90-05",
    "section": "",
    "text": "問題リンク"
  },
  {
    "objectID": "posts/at_coder/typical90-05.html#概要",
    "href": "posts/at_coder/typical90-05.html#概要",
    "title": "typical90-05",
    "section": "概要",
    "text": "概要\n解き切ってない。問題はアルゴリズムというよりかは、行列などの扱いや変数の大きさなどのようだ。\n//いつかリベンジ！！\n\nuse std::env;\nuse nalgebra::DMatrix;\nuse proconio::input;\n\nfn main() {\n    //env::set_var(\"RUST_BACKTRACE\", \"full\");\n    input! {\n        numbers_length: usize,\n        devider: usize,\n        digits: usize,\n        numbers: [usize; digits],\n    }\n\n    // 340282366920938463463374607431768211455\n    // 19318074092350443561\n    // 11710352956716025284\n\n    // for debug18446744073709551615\n\n    // let numbers_length: usize = 111;\n    // let devider : usize = 29;\n    // let digits: usize = 6;\n    // let numbers : Vec&lt;usize&gt;= vec![1,2,3,5,6,7,9];\n\n    let modular : u128 = 1000000007;\n\n    let mut rem_vec : Vec&lt;usize&gt; = vec![1];\n    let mut begin_index : usize = 0;\n    let mut end_index : usize= 0;\n    let mut loop_len : usize = 0;\n\n    for i in 0..devider {\n        let tmp_rem = (rem_vec.last().unwrap() * 10 ) % devider;\n        if rem_vec.binary_search(&tmp_rem).is_ok() {\n            begin_index = rem_vec.binary_search(&tmp_rem).unwrap();\n            end_index = rem_vec.len();\n            loop_len = end_index - begin_index;\n            break;\n        }\n        rem_vec.push( tmp_rem );\n    }\n\n    let (non_looped_side, looped_side) = rem_vec.split_at(begin_index);\n\n    // looped_rem[i][j] i*10^j-th % devider\n    let mut looped_rem : Vec&lt;Vec&lt;usize&gt;&gt; = Vec::new();\n    let mut non_looped_rem : Vec&lt;Vec&lt;usize&gt;&gt; = Vec::new();\n\n    for num in numbers {\n        let mut tmp_looped_rem = vec![];\n        let mut tmp_nonlooped_rem = vec![];\n        for i in looped_side {\n            tmp_looped_rem.push( (i * num) % devider );\n        }\n        looped_rem.push(tmp_looped_rem);\n        for i in non_looped_side {\n            tmp_nonlooped_rem.push( (i * num) % devider );\n        }\n        non_looped_rem.push(tmp_nonlooped_rem);\n    }\n\n    let mut beginning_vec : DMatrix&lt;u128&gt; = DMatrix::from_vec( devider, 1, vec![0; devider]);\n    beginning_vec[(0,0)] = 1;\n\n    // container[i][j] means how many numbers remain i in j-th digit in the loop\n    let mut looped_container : Vec&lt;DMatrix&lt;u128&gt;&gt; = Vec::new();\n\n    for jndex in 0..looped_rem[0].len() {\n        let mut vec_tmp_0 = vec![0 as u128; devider];\n\n        for index in 0..digits {\n            vec_tmp_0[looped_rem[index][jndex]] += 1;\n        }\n\n        looped_container.push(generate_calc_matrix(vec_tmp_0));\n    }\n\n    // container[i][j] means how many numbers remain i in j-th digit in the non-loop\n    let mut non_looped_container : Vec&lt;DMatrix&lt;u128&gt;&gt; = Vec::new();\n\n    if non_looped_rem.len() != 0 {\n        for jndex in 0..non_looped_rem[0].len() {\n            let mut vec_tmp_0 = vec![0 as u128; devider];\n            for index in 0..digits {\n                vec_tmp_0[non_looped_rem[index][jndex]] += 1;\n            }\n\n            non_looped_container.push(generate_calc_matrix(vec_tmp_0));\n        }\n    }\n\n    let ans = calc_mat(non_looped_container.clone(), looped_container.clone(), beginning_vec.clone(), numbers_length, modular);\n\n    println!(\"{}\", ans % modular as u128);\n\n}\n\nfn calc_mat(non_looped_container : Vec&lt;DMatrix&lt;u128&gt;&gt;, looped_container : Vec&lt;DMatrix&lt;u128&gt;&gt;, beginning_vec : DMatrix&lt;u128&gt;, number_length : usize, modular: u128) -&gt; u128 {\n    if non_looped_container.len() != 0 {\n        if non_looped_container.len() &gt;= number_length {\n            let mut tmp_mat = non_looped_container[0].clone();\n            for i in 1..number_length {\n                tmp_mat = &non_looped_container[i] * &tmp_mat;\n                for j in 0..tmp_mat.nrows() {\n                    for k in 0..tmp_mat.ncols() {\n                        tmp_mat[(j,k)] %= modular as u128;\n                    }\n                }\n            }\n            let ans = tmp_mat * beginning_vec;\n            let ans_u = ans[(0,0)];\n            return ans_u;\n        }\n        else {\n            let mut nl_tmp_mat = non_looped_container[0].clone();\n            for i in 1..non_looped_container.len() {\n                nl_tmp_mat = &non_looped_container[i] * &nl_tmp_mat;\n                for j in 0..nl_tmp_mat.nrows() {\n                    for k in 0..nl_tmp_mat.ncols() {\n                        nl_tmp_mat[(j,k)] %= modular;\n                    }\n                }\n            }\n            let mut new_beginning_vec = nl_tmp_mat * beginning_vec;\n\n            let loop_number = number_length - non_looped_container.len();\n\n            let ans = calc_looped(looped_container, new_beginning_vec, loop_number, modular);\n\n            let ans_u = ans[(0,0)];\n\n            return ans_u;\n        }\n    } else {\n        let ans = calc_looped(looped_container, beginning_vec, number_length, modular);\n\n        let ans_u = ans[(0,0)];\n\n        return ans_u;\n    }\n}\n\nfn calc_looped (looped_container : Vec&lt;DMatrix&lt;u128&gt;&gt;, beginning_vec : DMatrix&lt;u128&gt;, number_length : usize, modular : u128) -&gt; DMatrix&lt;u128&gt; {\n    if looped_container.len() &gt;= number_length {\n        let mut tmp_mat = looped_container[1].clone();\n        for i in 2..number_length {\n            tmp_mat = &looped_container[i] * &tmp_mat;\n            for j in 0..tmp_mat.nrows() {\n                for k in 0..tmp_mat.ncols() {\n                    tmp_mat[(j,k)] %= modular;\n                }\n            }\n        }\n        return tmp_mat * beginning_vec;\n    }\n    else {\n        let mut tmp_mat_one_loop = looped_container[0].clone();\n        for i in 1..looped_container.len() {\n            tmp_mat_one_loop = &looped_container[i] * &tmp_mat_one_loop;\n            for j in 0..tmp_mat_one_loop.nrows() {\n                for k in 0..tmp_mat_one_loop.ncols() {\n                    tmp_mat_one_loop[(j,k)] %= modular;\n                }\n            }\n        }\n\n        let loop_number = number_length / looped_container.len();\n\n        // １回のループでできる行列はできたので、あとはloop_number回のループを行う\n        let mut ans = calc_power(tmp_mat_one_loop, loop_number, modular);\n\n        let loop_number_remain = number_length % looped_container.len();\n\n        if loop_number_remain != 0 {\n            let mut tmp_mat = looped_container[0].clone();\n            for i in 1..loop_number_remain {\n                tmp_mat = &looped_container[i] * &tmp_mat;\n                for j in 0..tmp_mat.nrows() {\n                    for k in 0..tmp_mat.ncols() {\n                        tmp_mat[(j,k)] %= modular;\n                    }\n                }\n            }\n            ans = tmp_mat * ans;\n        }\n\n        for j in 0..ans.nrows() {\n            for k in 0..ans.ncols() {\n                ans[(j,k)] %= modular;\n            }\n        }\n\n        return ans * beginning_vec;\n    }\n}\n\nfn calc_power (mat: DMatrix&lt;u128&gt;, power : usize, modular : u128) -&gt; DMatrix&lt;u128&gt; {\n    let mut binary : Vec&lt;usize&gt; = format!(\"{:b}\", power).chars().map(|c| c.to_digit(10).unwrap() as usize).collect();\n\n    binary.reverse();\n\n    let mut ans_mat = DMatrix::from_element(mat.nrows(), mat.ncols(), 0);\n\n    for i in 0..binary.len() {\n        if binary[i] == 0 {\n            continue;\n        } else {\n            if ans_mat == DMatrix::from_element(mat.nrows(), mat.ncols(), 0) {\n                ans_mat = calc_binary_power(mat.clone(), i, modular);\n            }\n            else {\n                ans_mat = ans_mat * calc_binary_power(mat.clone(), i, modular);\n                for j in 0..ans_mat.nrows() {\n                    for k in 0..ans_mat.ncols() {\n                        ans_mat[(j,k)] %= modular;\n                    }\n                }\n            }\n\n        }\n    }\n\n\n\n    ans_mat\n}\n\nfn calc_binary_power (mat: DMatrix&lt;u128&gt;, power_size: usize, modular : u128) -&gt; DMatrix&lt;u128&gt; {\n    let mut ans_mat = DMatrix::from_element(mat.nrows(), mat.ncols(), 0);\n\n    if power_size == 0 {\n        return mat;\n    }\n\n    for i in 1..power_size+1 {\n        if i == 1 {\n            ans_mat = &mat * &mat;\n        } else {\n            ans_mat = &ans_mat * &ans_mat;\n            // alith\n            for j in 0..ans_mat.nrows() {\n                for k in 0..ans_mat.ncols() {\n                    ans_mat[(j,k)] %= modular;\n                }\n            }\n        }\n    }\n\n    ans_mat\n}\n\nfn generate_calc_matrix(rem_vec : Vec&lt;u128&gt;) -&gt; DMatrix&lt;u128&gt; {\n    let mut tmp_bm = vec![];\n\n    let size = rem_vec.len();\n\n    for index in 0..size {\n        let mut tmp_left = rem_vec[0..index+1].to_vec();\n        tmp_left.reverse();\n        let mut tmp_right = rem_vec[index+1..size].to_vec();\n        tmp_right.reverse();\n        let mut tmp_vec = tmp_left;\n        tmp_vec.append(&mut tmp_right);\n\n        tmp_bm.append(&mut tmp_vec);\n    }\n\n    DMatrix::from_vec(size, size, tmp_bm)\n}"
  },
  {
    "objectID": "posts/at_coder/typical90-05.html#発見",
    "href": "posts/at_coder/typical90-05.html#発見",
    "title": "typical90-05",
    "section": "発見",
    "text": "発見\n\nVecの中身を探すとき\nlet vec = vec![1,3,5];\nlet res1 = vec.binary_search(&2).is_ok();\nassert_eq!(res1, false);\nlet res2 = vec.binary_search(&3).is_ok();\nassert_eq!(res2, true);"
  },
  {
    "objectID": "posts/at_coder/typical90-05.html#問題点",
    "href": "posts/at_coder/typical90-05.html#問題点",
    "title": "typical90-05",
    "section": "問題点",
    "text": "問題点\n\nusize\nrustのusizeは基本64bitなので、大きすぎる値を考える時には向いていない。\n\n\n高速フーリエ変換\nやってなかったので、後々詳細を調べる。"
  },
  {
    "objectID": "posts/at_coder/typical90-10.html",
    "href": "posts/at_coder/typical90-10.html",
    "title": "typical90-10",
    "section": "",
    "text": "問題リンク\n累積和って言うらしい。知らんくても思いつくだろう。要するにいちいち計算するんじゃなくて、一気にまとめておいて後から計算するって話。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        cp: [[usize; 2]; n],\n        q: usize,\n        lr: [[usize; 2]; q],\n    }\n\n    // storageは累積和を格納する\n    // つまり、storage[i][0]はC_i番目の出席番号までの１組の期末点数の合計\n    let mut storage = vec![];\n\n    let mut tmp = vec![0,0];\n\n    for i in 0..n {\n        if cp[i][0] == 1 {\n            tmp[0] += cp[i][1];\n        } else {\n            tmp[1] += cp[i][1];\n        }\n        storage.push(tmp.clone());\n    }\n\n    for i in 0..q {\n        let l = lr[i][0] - 1;\n        let r = lr[i][1] - 1;\n\n        let mut ans = vec![0,0];\n        if l &gt; 0 {\n            ans[0] = storage[r][0] - storage[l-1][0];\n            ans[1] = storage[r][1] - storage[l-1][1];\n        } else {\n            ans[0] = storage[r][0];\n            ans[1] = storage[r][1];\n        }\n\n        println!(\"{} {}\", ans[0], ans[1]);\n    }\n\n}"
  },
  {
    "objectID": "posts/at_coder/typical90-10.html#概要",
    "href": "posts/at_coder/typical90-10.html#概要",
    "title": "typical90-10",
    "section": "",
    "text": "問題リンク\n累積和って言うらしい。知らんくても思いつくだろう。要するにいちいち計算するんじゃなくて、一気にまとめておいて後から計算するって話。\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        cp: [[usize; 2]; n],\n        q: usize,\n        lr: [[usize; 2]; q],\n    }\n\n    // storageは累積和を格納する\n    // つまり、storage[i][0]はC_i番目の出席番号までの１組の期末点数の合計\n    let mut storage = vec![];\n\n    let mut tmp = vec![0,0];\n\n    for i in 0..n {\n        if cp[i][0] == 1 {\n            tmp[0] += cp[i][1];\n        } else {\n            tmp[1] += cp[i][1];\n        }\n        storage.push(tmp.clone());\n    }\n\n    for i in 0..q {\n        let l = lr[i][0] - 1;\n        let r = lr[i][1] - 1;\n\n        let mut ans = vec![0,0];\n        if l &gt; 0 {\n            ans[0] = storage[r][0] - storage[l-1][0];\n            ans[1] = storage[r][1] - storage[l-1][1];\n        } else {\n            ans[0] = storage[r][0];\n            ans[1] = storage[r][1];\n        }\n\n        println!(\"{} {}\", ans[0], ans[1]);\n    }\n\n}"
  },
  {
    "objectID": "posts/at_coder/typical90-07.html",
    "href": "posts/at_coder/typical90-07.html",
    "title": "typical90-07",
    "section": "",
    "text": "問題リンク\nとりあえずBinary Searchすればいい。そうすれば計算量は \\(\\symscr{O}(Q\\ln N)\\) になる。 \\(\\ln\\) じゃなくて \\(\\log_{2}\\) だろうがという文句に対しては、定数倍してるだけだろうがという返答を投げつけますね。\nuse std::cmp;\n\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        mut a: [usize; n],\n        q: usize,\n        b: [usize; q],\n    }\n\n    a.sort();\n\n    for i in b.clone() {\n        let ans = cmp::min(\n            (a[(cmp::min(a.len() as isize - 1, binary_search(&a, i) as isize)) as usize] as isize\n                - i as isize)\n                .abs(),\n            (a[(cmp::max(0, binary_search(&a, i) as isize - 1)) as usize] as isize - i as isize)\n                .abs(),\n        );\n        println!(\"{}\", ans);\n    }\n}\n\nfn binary_search(a: &[usize], b: usize) -&gt; usize {\n    let mut left = 0;\n    let mut right = a.len();\n\n    while left &lt; right {\n        let mid = (left + right) / 2;\n        if a[mid] == b {\n            return mid;\n        } else if a[mid] &lt; b {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    left\n}\n見たらわかると思いますが、マジで競プロにRustは合わないっすね。真剣にNimに移行することを考えるレベルで。\nでも、私みたいな頑固なやつは何があってもRustを使い続けようとするんだろうなぁ。"
  },
  {
    "objectID": "posts/at_coder/typical90-07.html#概要",
    "href": "posts/at_coder/typical90-07.html#概要",
    "title": "typical90-07",
    "section": "",
    "text": "問題リンク\nとりあえずBinary Searchすればいい。そうすれば計算量は \\(\\symscr{O}(Q\\ln N)\\) になる。 \\(\\ln\\) じゃなくて \\(\\log_{2}\\) だろうがという文句に対しては、定数倍してるだけだろうがという返答を投げつけますね。\nuse std::cmp;\n\nuse proconio::input;\n\nfn main() {\n    input! {\n        n: usize,\n        mut a: [usize; n],\n        q: usize,\n        b: [usize; q],\n    }\n\n    a.sort();\n\n    for i in b.clone() {\n        let ans = cmp::min(\n            (a[(cmp::min(a.len() as isize - 1, binary_search(&a, i) as isize)) as usize] as isize\n                - i as isize)\n                .abs(),\n            (a[(cmp::max(0, binary_search(&a, i) as isize - 1)) as usize] as isize - i as isize)\n                .abs(),\n        );\n        println!(\"{}\", ans);\n    }\n}\n\nfn binary_search(a: &[usize], b: usize) -&gt; usize {\n    let mut left = 0;\n    let mut right = a.len();\n\n    while left &lt; right {\n        let mid = (left + right) / 2;\n        if a[mid] == b {\n            return mid;\n        } else if a[mid] &lt; b {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    left\n}\n見たらわかると思いますが、マジで競プロにRustは合わないっすね。真剣にNimに移行することを考えるレベルで。\nでも、私みたいな頑固なやつは何があってもRustを使い続けようとするんだろうなぁ。"
  },
  {
    "objectID": "posts/at_coder/typical90-07.html#発見",
    "href": "posts/at_coder/typical90-07.html#発見",
    "title": "typical90-07",
    "section": "発見",
    "text": "発見\n\n問題"
  },
  {
    "objectID": "posts/at_coder/typical90-07.html#問題点",
    "href": "posts/at_coder/typical90-07.html#問題点",
    "title": "typical90-07",
    "section": "問題点",
    "text": "問題点"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_05.html",
    "href": "posts/ue5_aura_courses/section_05.html",
    "title": "section_05",
    "section": "",
    "text": "section 05 UI\n\nUse UUserWidget BP Class to implement Widgets\n\nCreating Widget and Widget Controller C++ class.\nCreating a WBP derived from Widget class.\nMaking WBP reusable in other classes, Setting up contents in Hierachybars Variable.\n\nSetting up those variables by Blueprint\nWhen setting up padding “Slot as Overlay Slot” was used.\n\nMaking HUD Class.\n\nIn the HUD class, make a overlay variable.\nBP_HUD class.\nAlso creating a HUD Controller class\nCreating and add to viewport overlay widget\n\nSetting up Widget Controller\n\nCreating struct FWidgetControllerParams\nCreating Setter for controller based on FWidgetControllerParams.\n\nInit Widgets Function in HUD. Execute in CharacterController\nCreate Delegate for OnHealthChange\n\nUse DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam\nSetup Broadcast in Init\n\nBindcallback in Controller\n\nASC already has a delegate for valuechange: GetGameplayAttributeValueChangeDelegate\nBind Function to it and in that funtion, broadcasting controller’s onchanged delegate is a good way\n\nSetup Mana"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_05.html#概要",
    "href": "posts/ue5_aura_courses/section_05.html#概要",
    "title": "section_05",
    "section": "",
    "text": "section 05 UI\n\nUse UUserWidget BP Class to implement Widgets\n\nCreating Widget and Widget Controller C++ class.\nCreating a WBP derived from Widget class.\nMaking WBP reusable in other classes, Setting up contents in Hierachybars Variable.\n\nSetting up those variables by Blueprint\nWhen setting up padding “Slot as Overlay Slot” was used.\n\nMaking HUD Class.\n\nIn the HUD class, make a overlay variable.\nBP_HUD class.\nAlso creating a HUD Controller class\nCreating and add to viewport overlay widget\n\nSetting up Widget Controller\n\nCreating struct FWidgetControllerParams\nCreating Setter for controller based on FWidgetControllerParams.\n\nInit Widgets Function in HUD. Execute in CharacterController\nCreate Delegate for OnHealthChange\n\nUse DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam\nSetup Broadcast in Init\n\nBindcallback in Controller\n\nASC already has a delegate for valuechange: GetGameplayAttributeValueChangeDelegate\nBind Function to it and in that funtion, broadcasting controller’s onchanged delegate is a good way\n\nSetup Mana"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_05.html#発見",
    "href": "posts/ue5_aura_courses/section_05.html#発見",
    "title": "section_05",
    "section": "発見",
    "text": "発見\n\nSetting up Images by Slate Brush\nSlate Brushを使ってImagesのSet Brush関数で画像を定義した。\n\n\n\nHierarchie of HUD\n\n\n\n\nclassDiagram\n    note for HUD \"HUDは全てを含む\"\n    note for AuraUserWidget \"AuraUserWidgetはControllerを持っている\"\n    note for AuraUserWidgetController \"ControllerはWidgetを知る必要がない\"\n    class HUD{\n        +OverlayWidget\n        -OverlayWidgetController\n        -OverlayWidgetClass\n        -OverlayWidgetControllerClass\n        +GetOverlayWidgetController()\n        +SetOverlayWidgetController(FWidgetControllerParams)\n        +InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)\n    }\n    class AuraUserWidget {\n        +WidgetController\n        +SetWidgetController()\n        -WidgetControllerSet()\n    }\n    class AuraUserWidgetController {\n        -SetWidgetControllerParams()\n        +PlayerController\n        +PlayerState\n        +AbilitySystemComponent\n        +AttributeSet\n    }\n    class FWidgetControllerParams {\n        +PlayerController\n        +PlayerState\n        +AbilitySystemComponent\n        +AttributeSet\n    }\n    class BP_OverlayWidget{\n\n    }\n    class OverlayWdigetController {\n\n    }\n\n    OverlayWdigetController --|&gt; AuraUserWidgetController : Inheritance\n    BP_OverlayWidget --|&gt; AuraUserWidget : Inheritance\n    AuraUserWidgetController --* AuraUserWidget : Composition\n    OverlayWdigetController --* BP_OverlayWidget : Composition\n    BP_OverlayWidget --* HUD : Composition\n    FWidgetControllerParams ..&gt; AuraUserWidget : Defined in this\n\n\n\n\n\n\n\nDelegate について続き。\nDelegateは、いろんな関数のAdressをStoreしたもの。で、UEの場合、そのDelegateの定義は\n\n\nOverlayWidgetController.cpp\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnHealthChangedSignature, float, NewHealth);\n\nのようにする。これで定義したDelegateの変数の定義は\n\n\nOverlayWidgetController.cpp\n\nUPROPERTY(BlueprintAssignable, Category = \"GAS|Attributes\")\nFOnHealthChangedSignature OnHealthChanged;\n\nのようにしておき、この変数の中に関数のアドレスを入れるのに使うのは、他のcppファイルでやる。例えばWidgetはControllerを知っているけど、Controllerは知らないので、\n\n\nOverlayWidget.cpp\n\nvoid UOverlayWidget::WidgetControllerSet()\n{\n    WidgetController-&gt;OnHealthChanged.AddDynamic(this, &UOverlayWidget::OnHealthChanged)\n}\n\nvoid UOverlayWidget::OnHealthChanged(float NewHealth)\n{\n    percent = NewHealth / MaxHealth;\n}\n\nこんな感じに設定する。それで、このOnHealthChangedを呼びたいときは、\n\n\nOverlayWidgetController.cpp\n\nvoid UOverlayWidgetController::DealDamage()\n{\n    Health -= 10;\n\n    OnScoreChangedDelegate.Broadcast(Health)\n}\n\nとしている。けど、なんでControllerはWidget本体を知らない方がいいのか……？\n\n\nこれらについてもう少し考えてみる。\nつまりは、ControllerがCharacterとかのデータのやり取りを全てしており、WidgetがControllerにアクセスすればすべての欲しいものがあると。それから、全部のWidgetをTickさせながらアクセスするのは馬鹿らしいので、ControllerがDelegateを持って、Widget側がそれに関数をAssignさせ、Widgetに依存せずに知らないControllerが淡々とTickとUpdateをしていくわけだ。\nこうすることによって、Widgetの数が増えても、考えるべきなのはWidgetの中でDelegateにAssignする関数だけで済むし、Controllerは淡々と必用なVariablesを必用に応じてUpdateして、Delegateの実行、つまりBroadCastをしていくだけである。複雑になってもこれは変わらないので、Module性が高まる。\n\n\nSlot as Overlay SlotなどのUI関連\nComprehensiveなチュートリアルとかドキュメントとかを読む必要あり。"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_03.html",
    "href": "posts/ue5_aura_courses/section_03.html",
    "title": "section_03",
    "section": "",
    "text": "Sec 03 について"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_03.html#概要",
    "href": "posts/ue5_aura_courses/section_03.html#概要",
    "title": "section_03",
    "section": "概要",
    "text": "概要\n\nWhat is Gameplay Ability System: GAS?\n\nBuilt for Paragon but cancelled\nBest for RPGs\n\nAttach Ability System to Characters\n\nIt is possible to attach systems to Actor or Actor assosiated Class\n\nIn this course, we will attach to both for studying\n\n\nSetup GAS\n\nEnable Plugin in Plugin Setting and Build.cs\nCreate Ability System Component both on base-enemy and playerstate\n\ncreate default object for both abilitySystem and AttributeSet, and set replicated for AbilitySystem\n\nImpliment IAbilitySystemInterface on both characterbase and playerstate\n\nQuestion Why IAbilitySystemInterface? Why not normal getter?? Answer This is discribed in here\n\nSet player state belonging to controlled player\n\n\n\n\n\n\n\n\nNote\n\n\n\nDistinguish Owner Actor and Avatar Actor. For example, Aura enemy is both owner and avatar, player state is owner, controlled character is avatar. \n\n\n    1. Consider server side and client side\n        - detail will be inplemented in other lec\nvoid AAuraCharacter::InitAbilityActorInfo()\n{\n    AAuraPlayerState* AuraPlayerState = GetPlayerState&lt;AAuraPlayerState&gt;();\n    check(AuraPlayerState);\n    AuraPlayerState-&gt;GetAbilitySystemComponent()-&gt;InitAbilityActorInfo(AuraPlayerState, this);\n\n    AbilitySystemComponent = AuraPlayerState-&gt;GetAbilitySystemComponent();\n    AttributeSet = AuraPlayerState-&gt;GetAttributeSet();\n}\n\nvoid AAuraCharacter::PossessedBy(AController* NewController)\n{\n    Super::PossessedBy(NewController);\n\n    // Init ability system component for the server\n    InitAbilityActorInfo();\n}\n\nvoid AAuraCharacter::OnRep_PlayerState()\n{\n    Super::OnRep_PlayerState();\n\n    // Init ability system component for the client\n    InitAbilityActorInfo();\n}"
  },
  {
    "objectID": "posts/ue5_aura_courses/section_03.html#発見",
    "href": "posts/ue5_aura_courses/section_03.html#発見",
    "title": "section_03",
    "section": "発見",
    "text": "発見\n\nC++のディレクトリ構成を変更する際\n\nマジで面倒なので出来ればやらないこと。\nBinaryとIntermediateは消して、直接ディレクトリを編集する\nビルドしなおす。ただRiderでエディタを開いてもコンパイルエラーが出る\nEpic Game Launcherから直接開く\nRefresh Rider Projectを実行する\n\n\n\niCloudでの作業\nやめた方が良い。\nresource fork, Finder information, or similar detritus not allowed\nこんなエラーを吐いてくるが、\nxattr -cr .\nこれで解決できない。\n\n\nServer side と Client side の問題\nこれについては後でじっくりドキュメントを読む必要がありそうだ。"
  },
  {
    "objectID": "posts/収容所配布用/数学/数学I.html",
    "href": "posts/収容所配布用/数学/数学I.html",
    "title": "数学I",
    "section": "",
    "text": "次の \\(x\\) についての方程式の解を求めよ．ただし、 \\(0&lt;a&lt;\\frac{1}{4}\\) とする。\n\\[\nx^2 + 2ax + \\frac{1}{16} = -a + \\sqrt{a^2 + x - \\frac{1}{16}}\\;\n\\]"
  },
  {
    "objectID": "posts/収容所配布用/数学/数学I.html#section",
    "href": "posts/収容所配布用/数学/数学I.html#section",
    "title": "数学I",
    "section": "",
    "text": "次の \\(x\\) についての方程式の解を求めよ．ただし、 \\(0&lt;a&lt;\\frac{1}{4}\\) とする。\n\\[\nx^2 + 2ax + \\frac{1}{16} = -a + \\sqrt{a^2 + x - \\frac{1}{16}}\\;\n\\]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Serika’s Blog",
    "section": "",
    "text": "このブログでは、私個人の日記などの記録や、AtCoderやゲーム開発などでの進捗管理、情報発信をしていくつもりです。\n現時点での各セクションでの概要や目標は次のとおりです。\n\n\n\n\n\n\n\n\nセクション名\n概要\n目標\n\n\n\n\nAtCoder\nTypicala90を解いて行っています\nrustでAtCoderに挑戦する人にとって一助となるドキュメントになること\n\n\nUE5\nAuraというゲームを作るオンライン講義の記録\nコース完了後に自作のコピーゲームを作るときに参考にする\n\n\n大学用\n自作のシケプリを公開する場所\n参考になってくれれば嬉しい。そのうち消すかも\n\n\n収容所\n収容所で公開する問題を載せていく\nデータベース代わりになるといいかなと\n\n\nJournal\nただの日記\nできれば毎日投稿する\n\n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\ntypical90-11\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nNov 30, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\nPlanning\n\n\n\n\n\n\n\nUE5\n\n\nGame\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nNov 29, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-11-25\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nNov 25, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-10\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nNov 25, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\nsection_05\n\n\n\n\n\n\n\nUE5\n\n\nAura\n\n\nUdemy\n\n\nGame\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nNov 25, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-11-24\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nNov 24, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-09\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nNov 24, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\nsection_04\n\n\n\n\n\n\n\nUE5\n\n\nAura\n\n\nUdemy\n\n\nGame\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nNov 20, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-11-03\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nNov 3, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-08\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 26, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-07\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 25, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-23\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 23, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-06\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 23, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-17\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 17, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-05\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 17, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-16\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 16, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-04\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 16, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-15\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 15, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-03\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 15, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\nsection_03\n\n\n\n\n\n\n\nUE5\n\n\nAura\n\n\nUdemy\n\n\nGame\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 15, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-14\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 14, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n数学I\n\n\n\n\n\n\n\nMath\n\n\n\n\n\n\n\n\n\n\n\nOct 14, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-12\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 12, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-11\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 11, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n材料速度論\n\n\n\n\n\n\n\nUniversity\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 10, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n材料量子力学\n\n\n\n\n\n\n\nUniversity\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 10, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n材料相平衡論\n\n\n\n\n\n\n\nUniversity\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 10, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n統計力学\n\n\n\n\n\n\n\nUniversity\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 10, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-10\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 10, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\n2023-10-09\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntemplate\n\n\n\n\n\n\n\nJournal\n\n\n2023\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\nCargo Compete\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntemplate\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-02\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntypical90-01\n\n\n\n\n\n\n\nAtCoder\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\nSection 02\n\n\n\n\n\n\n\nUE5\n\n\nAura\n\n\nUdemy\n\n\nGame\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\n  \n\n\n\n\ntemplate\n\n\n\n\n\n\n\nUE5\n\n\nAura\n\n\nUdemy\n\n\nGame\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 9, 2023\n\n\nSerika Yuzuki\n\n\n\n\n\n\nNo matching items\n\n\n  \n\n Back to top"
  }
]